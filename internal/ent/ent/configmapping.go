// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/configmapping"
)

// ConfigMapping is the model entity for the ConfigMapping schema.
type ConfigMapping struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// ClientID holds the value of the "client_id" field.
	ClientID int32 `json:"client_id,omitempty"`
	// TotalTasks holds the value of the "total_tasks" field.
	TotalTasks int32 `json:"total_tasks,omitempty"`
	// Data start in this row index. Apply for excel, csv
	DataStartAtRow int32 `json:"data_start_at_row,omitempty"`
	// Default is first sheet in file
	DataAtSheet string `json:"data_at_sheet,omitempty"`
	// For example: A,B,C
	RequireColumnIndex string `json:"require_column_index,omitempty"`
	// Index of column, that FPS will fill when error happens
	ErrorColumnIndex string `json:"error_column_index,omitempty"`
	// JSON string, config new column in file result for display process result
	ResultFileConfig string `json:"result_file_config,omitempty"`
	// Time out of template in seconds (default 24h as 86400 seconds)
	Timeout int32 `json:"timeout,omitempty"`
	// Các định dạng cho phép của file input, cách nhau bằng dấu phẩy (ex: "XLS,XLSX,CSV")
	InputFileType string `json:"input_file_type,omitempty"`
	// Type of file output (XLS, XLSX, CSV). If null, output type is input type. If has value will force output type
	OutputFileType configmapping.OutputFileType `json:"output_file_type,omitempty"`
	// Max file size (MB) that client can upload
	MaxFileSize int32 `json:"max_file_size,omitempty"`
	// Tenant Id of client
	TenantID string `json:"tenant_id,omitempty"`
	// If 1, when import/get data, FPS will filter by sellerId, platformId,... (based on merchant_attribute_name value)
	UsingMerchantAttrName bool `json:"using_merchant_attr_name,omitempty"`
	// Attribute name of users attribute that is used for filtering data
	MerchantAttributeName string `json:"merchant_attribute_name,omitempty"`
	// UI config for client. Eg: show hide elements, change positions, ... Ref: https://confluence.teko.vn/display/SupplyChain/%5BFPS%5D+UI+Config
	UIConfig string `json:"ui_config,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// CreatedBy holds the value of the "created_by" field.
	CreatedBy string `json:"created_by,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ConfigMapping) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case configmapping.FieldUsingMerchantAttrName:
			values[i] = new(sql.NullBool)
		case configmapping.FieldID, configmapping.FieldClientID, configmapping.FieldTotalTasks, configmapping.FieldDataStartAtRow, configmapping.FieldTimeout, configmapping.FieldMaxFileSize:
			values[i] = new(sql.NullInt64)
		case configmapping.FieldDataAtSheet, configmapping.FieldRequireColumnIndex, configmapping.FieldErrorColumnIndex, configmapping.FieldResultFileConfig, configmapping.FieldInputFileType, configmapping.FieldOutputFileType, configmapping.FieldTenantID, configmapping.FieldMerchantAttributeName, configmapping.FieldUIConfig, configmapping.FieldCreatedBy:
			values[i] = new(sql.NullString)
		case configmapping.FieldCreatedAt, configmapping.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ConfigMapping", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ConfigMapping fields.
func (cm *ConfigMapping) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case configmapping.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			cm.ID = int(value.Int64)
		case configmapping.FieldClientID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field client_id", values[i])
			} else if value.Valid {
				cm.ClientID = int32(value.Int64)
			}
		case configmapping.FieldTotalTasks:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_tasks", values[i])
			} else if value.Valid {
				cm.TotalTasks = int32(value.Int64)
			}
		case configmapping.FieldDataStartAtRow:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field data_start_at_row", values[i])
			} else if value.Valid {
				cm.DataStartAtRow = int32(value.Int64)
			}
		case configmapping.FieldDataAtSheet:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field data_at_sheet", values[i])
			} else if value.Valid {
				cm.DataAtSheet = value.String
			}
		case configmapping.FieldRequireColumnIndex:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field require_column_index", values[i])
			} else if value.Valid {
				cm.RequireColumnIndex = value.String
			}
		case configmapping.FieldErrorColumnIndex:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_column_index", values[i])
			} else if value.Valid {
				cm.ErrorColumnIndex = value.String
			}
		case configmapping.FieldResultFileConfig:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field result_file_config", values[i])
			} else if value.Valid {
				cm.ResultFileConfig = value.String
			}
		case configmapping.FieldTimeout:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field timeout", values[i])
			} else if value.Valid {
				cm.Timeout = int32(value.Int64)
			}
		case configmapping.FieldInputFileType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field input_file_type", values[i])
			} else if value.Valid {
				cm.InputFileType = value.String
			}
		case configmapping.FieldOutputFileType:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field output_file_type", values[i])
			} else if value.Valid {
				cm.OutputFileType = configmapping.OutputFileType(value.String)
			}
		case configmapping.FieldMaxFileSize:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field max_file_size", values[i])
			} else if value.Valid {
				cm.MaxFileSize = int32(value.Int64)
			}
		case configmapping.FieldTenantID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value.Valid {
				cm.TenantID = value.String
			}
		case configmapping.FieldUsingMerchantAttrName:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field using_merchant_attr_name", values[i])
			} else if value.Valid {
				cm.UsingMerchantAttrName = value.Bool
			}
		case configmapping.FieldMerchantAttributeName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field merchant_attribute_name", values[i])
			} else if value.Valid {
				cm.MerchantAttributeName = value.String
			}
		case configmapping.FieldUIConfig:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field ui_config", values[i])
			} else if value.Valid {
				cm.UIConfig = value.String
			}
		case configmapping.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				cm.CreatedAt = value.Time
			}
		case configmapping.FieldCreatedBy:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field created_by", values[i])
			} else if value.Valid {
				cm.CreatedBy = value.String
			}
		case configmapping.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				cm.UpdatedAt = value.Time
			}
		}
	}
	return nil
}

// Update returns a builder for updating this ConfigMapping.
// Note that you need to call ConfigMapping.Unwrap() before calling this method if this ConfigMapping
// was returned from a transaction, and the transaction was committed or rolled back.
func (cm *ConfigMapping) Update() *ConfigMappingUpdateOne {
	return (&ConfigMappingClient{config: cm.config}).UpdateOne(cm)
}

// Unwrap unwraps the ConfigMapping entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (cm *ConfigMapping) Unwrap() *ConfigMapping {
	_tx, ok := cm.config.driver.(*txDriver)
	if !ok {
		panic("ent: ConfigMapping is not a transactional entity")
	}
	cm.config.driver = _tx.drv
	return cm
}

// String implements the fmt.Stringer.
func (cm *ConfigMapping) String() string {
	var builder strings.Builder
	builder.WriteString("ConfigMapping(")
	builder.WriteString(fmt.Sprintf("id=%v, ", cm.ID))
	builder.WriteString("client_id=")
	builder.WriteString(fmt.Sprintf("%v", cm.ClientID))
	builder.WriteString(", ")
	builder.WriteString("total_tasks=")
	builder.WriteString(fmt.Sprintf("%v", cm.TotalTasks))
	builder.WriteString(", ")
	builder.WriteString("data_start_at_row=")
	builder.WriteString(fmt.Sprintf("%v", cm.DataStartAtRow))
	builder.WriteString(", ")
	builder.WriteString("data_at_sheet=")
	builder.WriteString(cm.DataAtSheet)
	builder.WriteString(", ")
	builder.WriteString("require_column_index=")
	builder.WriteString(cm.RequireColumnIndex)
	builder.WriteString(", ")
	builder.WriteString("error_column_index=")
	builder.WriteString(cm.ErrorColumnIndex)
	builder.WriteString(", ")
	builder.WriteString("result_file_config=")
	builder.WriteString(cm.ResultFileConfig)
	builder.WriteString(", ")
	builder.WriteString("timeout=")
	builder.WriteString(fmt.Sprintf("%v", cm.Timeout))
	builder.WriteString(", ")
	builder.WriteString("input_file_type=")
	builder.WriteString(cm.InputFileType)
	builder.WriteString(", ")
	builder.WriteString("output_file_type=")
	builder.WriteString(fmt.Sprintf("%v", cm.OutputFileType))
	builder.WriteString(", ")
	builder.WriteString("max_file_size=")
	builder.WriteString(fmt.Sprintf("%v", cm.MaxFileSize))
	builder.WriteString(", ")
	builder.WriteString("tenant_id=")
	builder.WriteString(cm.TenantID)
	builder.WriteString(", ")
	builder.WriteString("using_merchant_attr_name=")
	builder.WriteString(fmt.Sprintf("%v", cm.UsingMerchantAttrName))
	builder.WriteString(", ")
	builder.WriteString("merchant_attribute_name=")
	builder.WriteString(cm.MerchantAttributeName)
	builder.WriteString(", ")
	builder.WriteString("ui_config=")
	builder.WriteString(cm.UIConfig)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(cm.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("created_by=")
	builder.WriteString(cm.CreatedBy)
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(cm.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// ConfigMappings is a parsable slice of ConfigMapping.
type ConfigMappings []*ConfigMapping

func (cm ConfigMappings) config(cfg config) {
	for _i := range cm {
		cm[_i].config = cfg
	}
}
