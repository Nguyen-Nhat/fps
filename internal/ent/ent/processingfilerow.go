// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"entgo.io/ent/dialect/sql"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerow"
)

// ProcessingFileRow is the model entity for the ProcessingFileRow schema.
type ProcessingFileRow struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// FileID holds the value of the "file_id" field.
	FileID int64 `json:"file_id,omitempty"`
	// RowIndex holds the value of the "row_index" field.
	RowIndex int32 `json:"row_index,omitempty"`
	// RowDataRaw holds the value of the "row_data_raw" field.
	RowDataRaw string `json:"row_data_raw,omitempty"`
	// TaskIndex holds the value of the "task_index" field.
	TaskIndex int32 `json:"task_index,omitempty"`
	// TaskMapping holds the value of the "task_mapping" field.
	TaskMapping string `json:"task_mapping,omitempty"`
	// TaskDependsOn holds the value of the "task_depends_on" field.
	TaskDependsOn string `json:"task_depends_on,omitempty"`
	// TaskRequestRaw holds the value of the "task_request_raw" field.
	TaskRequestRaw string `json:"task_request_raw,omitempty"`
	// TaskResponseRaw holds the value of the "task_response_raw" field.
	TaskResponseRaw string `json:"task_response_raw,omitempty"`
	// Init=1; ; Failed=3; Success=4; Timeout=5
	Status int16 `json:"status,omitempty"`
	// ErrorDisplay holds the value of the "error_display" field.
	ErrorDisplay string `json:"error_display,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProcessingFileRow) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case processingfilerow.FieldID, processingfilerow.FieldFileID, processingfilerow.FieldRowIndex, processingfilerow.FieldTaskIndex, processingfilerow.FieldStatus:
			values[i] = new(sql.NullInt64)
		case processingfilerow.FieldRowDataRaw, processingfilerow.FieldTaskMapping, processingfilerow.FieldTaskDependsOn, processingfilerow.FieldTaskRequestRaw, processingfilerow.FieldTaskResponseRaw, processingfilerow.FieldErrorDisplay:
			values[i] = new(sql.NullString)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ProcessingFileRow", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProcessingFileRow fields.
func (pfr *ProcessingFileRow) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case processingfilerow.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pfr.ID = int(value.Int64)
		case processingfilerow.FieldFileID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field file_id", values[i])
			} else if value.Valid {
				pfr.FileID = value.Int64
			}
		case processingfilerow.FieldRowIndex:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field row_index", values[i])
			} else if value.Valid {
				pfr.RowIndex = int32(value.Int64)
			}
		case processingfilerow.FieldRowDataRaw:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field row_data_raw", values[i])
			} else if value.Valid {
				pfr.RowDataRaw = value.String
			}
		case processingfilerow.FieldTaskIndex:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field task_index", values[i])
			} else if value.Valid {
				pfr.TaskIndex = int32(value.Int64)
			}
		case processingfilerow.FieldTaskMapping:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field task_mapping", values[i])
			} else if value.Valid {
				pfr.TaskMapping = value.String
			}
		case processingfilerow.FieldTaskDependsOn:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field task_depends_on", values[i])
			} else if value.Valid {
				pfr.TaskDependsOn = value.String
			}
		case processingfilerow.FieldTaskRequestRaw:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field task_request_raw", values[i])
			} else if value.Valid {
				pfr.TaskRequestRaw = value.String
			}
		case processingfilerow.FieldTaskResponseRaw:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field task_response_raw", values[i])
			} else if value.Valid {
				pfr.TaskResponseRaw = value.String
			}
		case processingfilerow.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				pfr.Status = int16(value.Int64)
			}
		case processingfilerow.FieldErrorDisplay:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_display", values[i])
			} else if value.Valid {
				pfr.ErrorDisplay = value.String
			}
		}
	}
	return nil
}

// Update returns a builder for updating this ProcessingFileRow.
// Note that you need to call ProcessingFileRow.Unwrap() before calling this method if this ProcessingFileRow
// was returned from a transaction, and the transaction was committed or rolled back.
func (pfr *ProcessingFileRow) Update() *ProcessingFileRowUpdateOne {
	return (&ProcessingFileRowClient{config: pfr.config}).UpdateOne(pfr)
}

// Unwrap unwraps the ProcessingFileRow entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pfr *ProcessingFileRow) Unwrap() *ProcessingFileRow {
	_tx, ok := pfr.config.driver.(*txDriver)
	if !ok {
		panic("ent: ProcessingFileRow is not a transactional entity")
	}
	pfr.config.driver = _tx.drv
	return pfr
}

// String implements the fmt.Stringer.
func (pfr *ProcessingFileRow) String() string {
	var builder strings.Builder
	builder.WriteString("ProcessingFileRow(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pfr.ID))
	builder.WriteString("file_id=")
	builder.WriteString(fmt.Sprintf("%v", pfr.FileID))
	builder.WriteString(", ")
	builder.WriteString("row_index=")
	builder.WriteString(fmt.Sprintf("%v", pfr.RowIndex))
	builder.WriteString(", ")
	builder.WriteString("row_data_raw=")
	builder.WriteString(pfr.RowDataRaw)
	builder.WriteString(", ")
	builder.WriteString("task_index=")
	builder.WriteString(fmt.Sprintf("%v", pfr.TaskIndex))
	builder.WriteString(", ")
	builder.WriteString("task_mapping=")
	builder.WriteString(pfr.TaskMapping)
	builder.WriteString(", ")
	builder.WriteString("task_depends_on=")
	builder.WriteString(pfr.TaskDependsOn)
	builder.WriteString(", ")
	builder.WriteString("task_request_raw=")
	builder.WriteString(pfr.TaskRequestRaw)
	builder.WriteString(", ")
	builder.WriteString("task_response_raw=")
	builder.WriteString(pfr.TaskResponseRaw)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", pfr.Status))
	builder.WriteString(", ")
	builder.WriteString("error_display=")
	builder.WriteString(pfr.ErrorDisplay)
	builder.WriteByte(')')
	return builder.String()
}

// ProcessingFileRows is a parsable slice of ProcessingFileRow.
type ProcessingFileRows []*ProcessingFileRow

func (pfr ProcessingFileRows) config(cfg config) {
	for _i := range pfr {
		pfr[_i].config = cfg
	}
}
