// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"
	"time"

	"entgo.io/ent/dialect/sql"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerowgroup"
)

// ProcessingFileRowGroup is the model entity for the ProcessingFileRowGroup schema.
type ProcessingFileRowGroup struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// File ID
	FileID int64 `json:"file_id,omitempty"`
	// Task Index
	TaskIndex int32 `json:"task_index,omitempty"`
	// Group by value, that is get from data in file excel
	GroupByValue string `json:"group_by_value,omitempty"`
	// Total rows that have same group_by_value
	TotalRows int32 `json:"total_rows,omitempty"`
	// List of row index, split by comma
	RowIndexList string `json:"row_index_list,omitempty"`
	// Request cURL
	GroupRequestCurl string `json:"group_request_curl,omitempty"`
	// Response raw
	GroupResponseRaw string `json:"group_response_raw,omitempty"`
	// Init=1; Processing=2; Failed=3; Success=4;
	Status int16 `json:"status,omitempty"`
	// Error for displaying
	ErrorDisplay string `json:"error_display,omitempty"`
	// Executed time
	ExecutedTime int64 `json:"executed_time,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// UpdatedAt holds the value of the "updated_at" field.
	UpdatedAt time.Time `json:"updated_at,omitempty"`
}

// scanValues returns the types for scanning values from sql.Rows.
func (*ProcessingFileRowGroup) scanValues(columns []string) ([]interface{}, error) {
	values := make([]interface{}, len(columns))
	for i := range columns {
		switch columns[i] {
		case processingfilerowgroup.FieldID, processingfilerowgroup.FieldFileID, processingfilerowgroup.FieldTaskIndex, processingfilerowgroup.FieldTotalRows, processingfilerowgroup.FieldStatus, processingfilerowgroup.FieldExecutedTime:
			values[i] = new(sql.NullInt64)
		case processingfilerowgroup.FieldGroupByValue, processingfilerowgroup.FieldRowIndexList, processingfilerowgroup.FieldGroupRequestCurl, processingfilerowgroup.FieldGroupResponseRaw, processingfilerowgroup.FieldErrorDisplay:
			values[i] = new(sql.NullString)
		case processingfilerowgroup.FieldCreatedAt, processingfilerowgroup.FieldUpdatedAt:
			values[i] = new(sql.NullTime)
		default:
			return nil, fmt.Errorf("unexpected column %q for type ProcessingFileRowGroup", columns[i])
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the ProcessingFileRowGroup fields.
func (pfrg *ProcessingFileRowGroup) assignValues(columns []string, values []interface{}) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case processingfilerowgroup.FieldID:
			value, ok := values[i].(*sql.NullInt64)
			if !ok {
				return fmt.Errorf("unexpected type %T for field id", value)
			}
			pfrg.ID = int(value.Int64)
		case processingfilerowgroup.FieldFileID:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field file_id", values[i])
			} else if value.Valid {
				pfrg.FileID = value.Int64
			}
		case processingfilerowgroup.FieldTaskIndex:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field task_index", values[i])
			} else if value.Valid {
				pfrg.TaskIndex = int32(value.Int64)
			}
		case processingfilerowgroup.FieldGroupByValue:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field group_by_value", values[i])
			} else if value.Valid {
				pfrg.GroupByValue = value.String
			}
		case processingfilerowgroup.FieldTotalRows:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field total_rows", values[i])
			} else if value.Valid {
				pfrg.TotalRows = int32(value.Int64)
			}
		case processingfilerowgroup.FieldRowIndexList:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field row_index_list", values[i])
			} else if value.Valid {
				pfrg.RowIndexList = value.String
			}
		case processingfilerowgroup.FieldGroupRequestCurl:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field group_request_curl", values[i])
			} else if value.Valid {
				pfrg.GroupRequestCurl = value.String
			}
		case processingfilerowgroup.FieldGroupResponseRaw:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field group_response_raw", values[i])
			} else if value.Valid {
				pfrg.GroupResponseRaw = value.String
			}
		case processingfilerowgroup.FieldStatus:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				pfrg.Status = int16(value.Int64)
			}
		case processingfilerowgroup.FieldErrorDisplay:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field error_display", values[i])
			} else if value.Valid {
				pfrg.ErrorDisplay = value.String
			}
		case processingfilerowgroup.FieldExecutedTime:
			if value, ok := values[i].(*sql.NullInt64); !ok {
				return fmt.Errorf("unexpected type %T for field executed_time", values[i])
			} else if value.Valid {
				pfrg.ExecutedTime = value.Int64
			}
		case processingfilerowgroup.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				pfrg.CreatedAt = value.Time
			}
		case processingfilerowgroup.FieldUpdatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field updated_at", values[i])
			} else if value.Valid {
				pfrg.UpdatedAt = value.Time
			}
		}
	}
	return nil
}

// Update returns a builder for updating this ProcessingFileRowGroup.
// Note that you need to call ProcessingFileRowGroup.Unwrap() before calling this method if this ProcessingFileRowGroup
// was returned from a transaction, and the transaction was committed or rolled back.
func (pfrg *ProcessingFileRowGroup) Update() *ProcessingFileRowGroupUpdateOne {
	return (&ProcessingFileRowGroupClient{config: pfrg.config}).UpdateOne(pfrg)
}

// Unwrap unwraps the ProcessingFileRowGroup entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (pfrg *ProcessingFileRowGroup) Unwrap() *ProcessingFileRowGroup {
	_tx, ok := pfrg.config.driver.(*txDriver)
	if !ok {
		panic("ent: ProcessingFileRowGroup is not a transactional entity")
	}
	pfrg.config.driver = _tx.drv
	return pfrg
}

// String implements the fmt.Stringer.
func (pfrg *ProcessingFileRowGroup) String() string {
	var builder strings.Builder
	builder.WriteString("ProcessingFileRowGroup(")
	builder.WriteString(fmt.Sprintf("id=%v, ", pfrg.ID))
	builder.WriteString("file_id=")
	builder.WriteString(fmt.Sprintf("%v", pfrg.FileID))
	builder.WriteString(", ")
	builder.WriteString("task_index=")
	builder.WriteString(fmt.Sprintf("%v", pfrg.TaskIndex))
	builder.WriteString(", ")
	builder.WriteString("group_by_value=")
	builder.WriteString(pfrg.GroupByValue)
	builder.WriteString(", ")
	builder.WriteString("total_rows=")
	builder.WriteString(fmt.Sprintf("%v", pfrg.TotalRows))
	builder.WriteString(", ")
	builder.WriteString("row_index_list=")
	builder.WriteString(pfrg.RowIndexList)
	builder.WriteString(", ")
	builder.WriteString("group_request_curl=")
	builder.WriteString(pfrg.GroupRequestCurl)
	builder.WriteString(", ")
	builder.WriteString("group_response_raw=")
	builder.WriteString(pfrg.GroupResponseRaw)
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", pfrg.Status))
	builder.WriteString(", ")
	builder.WriteString("error_display=")
	builder.WriteString(pfrg.ErrorDisplay)
	builder.WriteString(", ")
	builder.WriteString("executed_time=")
	builder.WriteString(fmt.Sprintf("%v", pfrg.ExecutedTime))
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(pfrg.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("updated_at=")
	builder.WriteString(pfrg.UpdatedAt.Format(time.ANSIC))
	builder.WriteByte(')')
	return builder.String()
}

// ProcessingFileRowGroups is a parsable slice of ProcessingFileRowGroup.
type ProcessingFileRowGroups []*ProcessingFileRowGroup

func (pfrg ProcessingFileRowGroups) config(cfg config) {
	for _i := range pfrg {
		pfrg[_i].config = cfg
	}
}
