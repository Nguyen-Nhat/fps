// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/configmapping"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/configtask"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/fpsclient"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/predicate"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfile"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerow"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerowgroup"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeConfigMapping          = "ConfigMapping"
	TypeConfigTask             = "ConfigTask"
	TypeFpsClient              = "FpsClient"
	TypeProcessingFile         = "ProcessingFile"
	TypeProcessingFileRow      = "ProcessingFileRow"
	TypeProcessingFileRowGroup = "ProcessingFileRowGroup"
	TypeUser                   = "User"
)

// ConfigMappingMutation represents an operation that mutates the ConfigMapping nodes in the graph.
type ConfigMappingMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	client_id            *int32
	addclient_id         *int32
	total_tasks          *int32
	addtotal_tasks       *int32
	data_start_at_row    *int32
	adddata_start_at_row *int32
	data_at_sheet        *string
	require_column_index *string
	error_column_index   *string
	result_file_config   *string
	timeout              *int32
	addtimeout           *int32
	input_file_type      *string
	output_file_type     *configmapping.OutputFileType
	created_at           *time.Time
	created_by           *string
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*ConfigMapping, error)
	predicates           []predicate.ConfigMapping
}

var _ ent.Mutation = (*ConfigMappingMutation)(nil)

// configmappingOption allows management of the mutation configuration using functional options.
type configmappingOption func(*ConfigMappingMutation)

// newConfigMappingMutation creates new mutation for the ConfigMapping entity.
func newConfigMappingMutation(c config, op Op, opts ...configmappingOption) *ConfigMappingMutation {
	m := &ConfigMappingMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigMapping,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigMappingID sets the ID field of the mutation.
func withConfigMappingID(id int) configmappingOption {
	return func(m *ConfigMappingMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigMapping
		)
		m.oldValue = func(ctx context.Context) (*ConfigMapping, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigMapping.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigMapping sets the old ConfigMapping of the mutation.
func withConfigMapping(node *ConfigMapping) configmappingOption {
	return func(m *ConfigMappingMutation) {
		m.oldValue = func(context.Context) (*ConfigMapping, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigMappingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigMappingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigMappingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigMappingMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigMapping.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *ConfigMappingMutation) SetClientID(i int32) {
	m.client_id = &i
	m.addclient_id = nil
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ConfigMappingMutation) ClientID() (r int32, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldClientID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// AddClientID adds i to the "client_id" field.
func (m *ConfigMappingMutation) AddClientID(i int32) {
	if m.addclient_id != nil {
		*m.addclient_id += i
	} else {
		m.addclient_id = &i
	}
}

// AddedClientID returns the value that was added to the "client_id" field in this mutation.
func (m *ConfigMappingMutation) AddedClientID() (r int32, exists bool) {
	v := m.addclient_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ConfigMappingMutation) ResetClientID() {
	m.client_id = nil
	m.addclient_id = nil
}

// SetTotalTasks sets the "total_tasks" field.
func (m *ConfigMappingMutation) SetTotalTasks(i int32) {
	m.total_tasks = &i
	m.addtotal_tasks = nil
}

// TotalTasks returns the value of the "total_tasks" field in the mutation.
func (m *ConfigMappingMutation) TotalTasks() (r int32, exists bool) {
	v := m.total_tasks
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalTasks returns the old "total_tasks" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldTotalTasks(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalTasks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalTasks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalTasks: %w", err)
	}
	return oldValue.TotalTasks, nil
}

// AddTotalTasks adds i to the "total_tasks" field.
func (m *ConfigMappingMutation) AddTotalTasks(i int32) {
	if m.addtotal_tasks != nil {
		*m.addtotal_tasks += i
	} else {
		m.addtotal_tasks = &i
	}
}

// AddedTotalTasks returns the value that was added to the "total_tasks" field in this mutation.
func (m *ConfigMappingMutation) AddedTotalTasks() (r int32, exists bool) {
	v := m.addtotal_tasks
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalTasks resets all changes to the "total_tasks" field.
func (m *ConfigMappingMutation) ResetTotalTasks() {
	m.total_tasks = nil
	m.addtotal_tasks = nil
}

// SetDataStartAtRow sets the "data_start_at_row" field.
func (m *ConfigMappingMutation) SetDataStartAtRow(i int32) {
	m.data_start_at_row = &i
	m.adddata_start_at_row = nil
}

// DataStartAtRow returns the value of the "data_start_at_row" field in the mutation.
func (m *ConfigMappingMutation) DataStartAtRow() (r int32, exists bool) {
	v := m.data_start_at_row
	if v == nil {
		return
	}
	return *v, true
}

// OldDataStartAtRow returns the old "data_start_at_row" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldDataStartAtRow(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataStartAtRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataStartAtRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataStartAtRow: %w", err)
	}
	return oldValue.DataStartAtRow, nil
}

// AddDataStartAtRow adds i to the "data_start_at_row" field.
func (m *ConfigMappingMutation) AddDataStartAtRow(i int32) {
	if m.adddata_start_at_row != nil {
		*m.adddata_start_at_row += i
	} else {
		m.adddata_start_at_row = &i
	}
}

// AddedDataStartAtRow returns the value that was added to the "data_start_at_row" field in this mutation.
func (m *ConfigMappingMutation) AddedDataStartAtRow() (r int32, exists bool) {
	v := m.adddata_start_at_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetDataStartAtRow resets all changes to the "data_start_at_row" field.
func (m *ConfigMappingMutation) ResetDataStartAtRow() {
	m.data_start_at_row = nil
	m.adddata_start_at_row = nil
}

// SetDataAtSheet sets the "data_at_sheet" field.
func (m *ConfigMappingMutation) SetDataAtSheet(s string) {
	m.data_at_sheet = &s
}

// DataAtSheet returns the value of the "data_at_sheet" field in the mutation.
func (m *ConfigMappingMutation) DataAtSheet() (r string, exists bool) {
	v := m.data_at_sheet
	if v == nil {
		return
	}
	return *v, true
}

// OldDataAtSheet returns the old "data_at_sheet" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldDataAtSheet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataAtSheet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataAtSheet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataAtSheet: %w", err)
	}
	return oldValue.DataAtSheet, nil
}

// ResetDataAtSheet resets all changes to the "data_at_sheet" field.
func (m *ConfigMappingMutation) ResetDataAtSheet() {
	m.data_at_sheet = nil
}

// SetRequireColumnIndex sets the "require_column_index" field.
func (m *ConfigMappingMutation) SetRequireColumnIndex(s string) {
	m.require_column_index = &s
}

// RequireColumnIndex returns the value of the "require_column_index" field in the mutation.
func (m *ConfigMappingMutation) RequireColumnIndex() (r string, exists bool) {
	v := m.require_column_index
	if v == nil {
		return
	}
	return *v, true
}

// OldRequireColumnIndex returns the old "require_column_index" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldRequireColumnIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequireColumnIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequireColumnIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequireColumnIndex: %w", err)
	}
	return oldValue.RequireColumnIndex, nil
}

// ResetRequireColumnIndex resets all changes to the "require_column_index" field.
func (m *ConfigMappingMutation) ResetRequireColumnIndex() {
	m.require_column_index = nil
}

// SetErrorColumnIndex sets the "error_column_index" field.
func (m *ConfigMappingMutation) SetErrorColumnIndex(s string) {
	m.error_column_index = &s
}

// ErrorColumnIndex returns the value of the "error_column_index" field in the mutation.
func (m *ConfigMappingMutation) ErrorColumnIndex() (r string, exists bool) {
	v := m.error_column_index
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorColumnIndex returns the old "error_column_index" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldErrorColumnIndex(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorColumnIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorColumnIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorColumnIndex: %w", err)
	}
	return oldValue.ErrorColumnIndex, nil
}

// ResetErrorColumnIndex resets all changes to the "error_column_index" field.
func (m *ConfigMappingMutation) ResetErrorColumnIndex() {
	m.error_column_index = nil
}

// SetResultFileConfig sets the "result_file_config" field.
func (m *ConfigMappingMutation) SetResultFileConfig(s string) {
	m.result_file_config = &s
}

// ResultFileConfig returns the value of the "result_file_config" field in the mutation.
func (m *ConfigMappingMutation) ResultFileConfig() (r string, exists bool) {
	v := m.result_file_config
	if v == nil {
		return
	}
	return *v, true
}

// OldResultFileConfig returns the old "result_file_config" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldResultFileConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultFileConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultFileConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultFileConfig: %w", err)
	}
	return oldValue.ResultFileConfig, nil
}

// ClearResultFileConfig clears the value of the "result_file_config" field.
func (m *ConfigMappingMutation) ClearResultFileConfig() {
	m.result_file_config = nil
	m.clearedFields[configmapping.FieldResultFileConfig] = struct{}{}
}

// ResultFileConfigCleared returns if the "result_file_config" field was cleared in this mutation.
func (m *ConfigMappingMutation) ResultFileConfigCleared() bool {
	_, ok := m.clearedFields[configmapping.FieldResultFileConfig]
	return ok
}

// ResetResultFileConfig resets all changes to the "result_file_config" field.
func (m *ConfigMappingMutation) ResetResultFileConfig() {
	m.result_file_config = nil
	delete(m.clearedFields, configmapping.FieldResultFileConfig)
}

// SetTimeout sets the "timeout" field.
func (m *ConfigMappingMutation) SetTimeout(i int32) {
	m.timeout = &i
	m.addtimeout = nil
}

// Timeout returns the value of the "timeout" field in the mutation.
func (m *ConfigMappingMutation) Timeout() (r int32, exists bool) {
	v := m.timeout
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeout returns the old "timeout" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldTimeout(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTimeout is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTimeout requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeout: %w", err)
	}
	return oldValue.Timeout, nil
}

// AddTimeout adds i to the "timeout" field.
func (m *ConfigMappingMutation) AddTimeout(i int32) {
	if m.addtimeout != nil {
		*m.addtimeout += i
	} else {
		m.addtimeout = &i
	}
}

// AddedTimeout returns the value that was added to the "timeout" field in this mutation.
func (m *ConfigMappingMutation) AddedTimeout() (r int32, exists bool) {
	v := m.addtimeout
	if v == nil {
		return
	}
	return *v, true
}

// ResetTimeout resets all changes to the "timeout" field.
func (m *ConfigMappingMutation) ResetTimeout() {
	m.timeout = nil
	m.addtimeout = nil
}

// SetInputFileType sets the "input_file_type" field.
func (m *ConfigMappingMutation) SetInputFileType(s string) {
	m.input_file_type = &s
}

// InputFileType returns the value of the "input_file_type" field in the mutation.
func (m *ConfigMappingMutation) InputFileType() (r string, exists bool) {
	v := m.input_file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldInputFileType returns the old "input_file_type" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldInputFileType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInputFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInputFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInputFileType: %w", err)
	}
	return oldValue.InputFileType, nil
}

// ResetInputFileType resets all changes to the "input_file_type" field.
func (m *ConfigMappingMutation) ResetInputFileType() {
	m.input_file_type = nil
}

// SetOutputFileType sets the "output_file_type" field.
func (m *ConfigMappingMutation) SetOutputFileType(cft configmapping.OutputFileType) {
	m.output_file_type = &cft
}

// OutputFileType returns the value of the "output_file_type" field in the mutation.
func (m *ConfigMappingMutation) OutputFileType() (r configmapping.OutputFileType, exists bool) {
	v := m.output_file_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutputFileType returns the old "output_file_type" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldOutputFileType(ctx context.Context) (v configmapping.OutputFileType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutputFileType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutputFileType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutputFileType: %w", err)
	}
	return oldValue.OutputFileType, nil
}

// ClearOutputFileType clears the value of the "output_file_type" field.
func (m *ConfigMappingMutation) ClearOutputFileType() {
	m.output_file_type = nil
	m.clearedFields[configmapping.FieldOutputFileType] = struct{}{}
}

// OutputFileTypeCleared returns if the "output_file_type" field was cleared in this mutation.
func (m *ConfigMappingMutation) OutputFileTypeCleared() bool {
	_, ok := m.clearedFields[configmapping.FieldOutputFileType]
	return ok
}

// ResetOutputFileType resets all changes to the "output_file_type" field.
func (m *ConfigMappingMutation) ResetOutputFileType() {
	m.output_file_type = nil
	delete(m.clearedFields, configmapping.FieldOutputFileType)
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigMappingMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigMappingMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigMappingMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConfigMappingMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConfigMappingMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConfigMappingMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigMappingMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigMappingMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigMapping entity.
// If the ConfigMapping object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigMappingMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigMappingMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigMappingMutation builder.
func (m *ConfigMappingMutation) Where(ps ...predicate.ConfigMapping) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConfigMappingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ConfigMapping).
func (m *ConfigMappingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigMappingMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.client_id != nil {
		fields = append(fields, configmapping.FieldClientID)
	}
	if m.total_tasks != nil {
		fields = append(fields, configmapping.FieldTotalTasks)
	}
	if m.data_start_at_row != nil {
		fields = append(fields, configmapping.FieldDataStartAtRow)
	}
	if m.data_at_sheet != nil {
		fields = append(fields, configmapping.FieldDataAtSheet)
	}
	if m.require_column_index != nil {
		fields = append(fields, configmapping.FieldRequireColumnIndex)
	}
	if m.error_column_index != nil {
		fields = append(fields, configmapping.FieldErrorColumnIndex)
	}
	if m.result_file_config != nil {
		fields = append(fields, configmapping.FieldResultFileConfig)
	}
	if m.timeout != nil {
		fields = append(fields, configmapping.FieldTimeout)
	}
	if m.input_file_type != nil {
		fields = append(fields, configmapping.FieldInputFileType)
	}
	if m.output_file_type != nil {
		fields = append(fields, configmapping.FieldOutputFileType)
	}
	if m.created_at != nil {
		fields = append(fields, configmapping.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, configmapping.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, configmapping.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigMappingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configmapping.FieldClientID:
		return m.ClientID()
	case configmapping.FieldTotalTasks:
		return m.TotalTasks()
	case configmapping.FieldDataStartAtRow:
		return m.DataStartAtRow()
	case configmapping.FieldDataAtSheet:
		return m.DataAtSheet()
	case configmapping.FieldRequireColumnIndex:
		return m.RequireColumnIndex()
	case configmapping.FieldErrorColumnIndex:
		return m.ErrorColumnIndex()
	case configmapping.FieldResultFileConfig:
		return m.ResultFileConfig()
	case configmapping.FieldTimeout:
		return m.Timeout()
	case configmapping.FieldInputFileType:
		return m.InputFileType()
	case configmapping.FieldOutputFileType:
		return m.OutputFileType()
	case configmapping.FieldCreatedAt:
		return m.CreatedAt()
	case configmapping.FieldCreatedBy:
		return m.CreatedBy()
	case configmapping.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigMappingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configmapping.FieldClientID:
		return m.OldClientID(ctx)
	case configmapping.FieldTotalTasks:
		return m.OldTotalTasks(ctx)
	case configmapping.FieldDataStartAtRow:
		return m.OldDataStartAtRow(ctx)
	case configmapping.FieldDataAtSheet:
		return m.OldDataAtSheet(ctx)
	case configmapping.FieldRequireColumnIndex:
		return m.OldRequireColumnIndex(ctx)
	case configmapping.FieldErrorColumnIndex:
		return m.OldErrorColumnIndex(ctx)
	case configmapping.FieldResultFileConfig:
		return m.OldResultFileConfig(ctx)
	case configmapping.FieldTimeout:
		return m.OldTimeout(ctx)
	case configmapping.FieldInputFileType:
		return m.OldInputFileType(ctx)
	case configmapping.FieldOutputFileType:
		return m.OldOutputFileType(ctx)
	case configmapping.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configmapping.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case configmapping.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigMapping field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigMappingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configmapping.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case configmapping.FieldTotalTasks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalTasks(v)
		return nil
	case configmapping.FieldDataStartAtRow:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataStartAtRow(v)
		return nil
	case configmapping.FieldDataAtSheet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataAtSheet(v)
		return nil
	case configmapping.FieldRequireColumnIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequireColumnIndex(v)
		return nil
	case configmapping.FieldErrorColumnIndex:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorColumnIndex(v)
		return nil
	case configmapping.FieldResultFileConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultFileConfig(v)
		return nil
	case configmapping.FieldTimeout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeout(v)
		return nil
	case configmapping.FieldInputFileType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInputFileType(v)
		return nil
	case configmapping.FieldOutputFileType:
		v, ok := value.(configmapping.OutputFileType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutputFileType(v)
		return nil
	case configmapping.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configmapping.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case configmapping.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigMapping field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigMappingMutation) AddedFields() []string {
	var fields []string
	if m.addclient_id != nil {
		fields = append(fields, configmapping.FieldClientID)
	}
	if m.addtotal_tasks != nil {
		fields = append(fields, configmapping.FieldTotalTasks)
	}
	if m.adddata_start_at_row != nil {
		fields = append(fields, configmapping.FieldDataStartAtRow)
	}
	if m.addtimeout != nil {
		fields = append(fields, configmapping.FieldTimeout)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigMappingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configmapping.FieldClientID:
		return m.AddedClientID()
	case configmapping.FieldTotalTasks:
		return m.AddedTotalTasks()
	case configmapping.FieldDataStartAtRow:
		return m.AddedDataStartAtRow()
	case configmapping.FieldTimeout:
		return m.AddedTimeout()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigMappingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configmapping.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientID(v)
		return nil
	case configmapping.FieldTotalTasks:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalTasks(v)
		return nil
	case configmapping.FieldDataStartAtRow:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDataStartAtRow(v)
		return nil
	case configmapping.FieldTimeout:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTimeout(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigMapping numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigMappingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(configmapping.FieldResultFileConfig) {
		fields = append(fields, configmapping.FieldResultFileConfig)
	}
	if m.FieldCleared(configmapping.FieldOutputFileType) {
		fields = append(fields, configmapping.FieldOutputFileType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigMappingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigMappingMutation) ClearField(name string) error {
	switch name {
	case configmapping.FieldResultFileConfig:
		m.ClearResultFileConfig()
		return nil
	case configmapping.FieldOutputFileType:
		m.ClearOutputFileType()
		return nil
	}
	return fmt.Errorf("unknown ConfigMapping nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigMappingMutation) ResetField(name string) error {
	switch name {
	case configmapping.FieldClientID:
		m.ResetClientID()
		return nil
	case configmapping.FieldTotalTasks:
		m.ResetTotalTasks()
		return nil
	case configmapping.FieldDataStartAtRow:
		m.ResetDataStartAtRow()
		return nil
	case configmapping.FieldDataAtSheet:
		m.ResetDataAtSheet()
		return nil
	case configmapping.FieldRequireColumnIndex:
		m.ResetRequireColumnIndex()
		return nil
	case configmapping.FieldErrorColumnIndex:
		m.ResetErrorColumnIndex()
		return nil
	case configmapping.FieldResultFileConfig:
		m.ResetResultFileConfig()
		return nil
	case configmapping.FieldTimeout:
		m.ResetTimeout()
		return nil
	case configmapping.FieldInputFileType:
		m.ResetInputFileType()
		return nil
	case configmapping.FieldOutputFileType:
		m.ResetOutputFileType()
		return nil
	case configmapping.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configmapping.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case configmapping.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigMapping field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigMappingMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigMappingMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigMappingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigMappingMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigMappingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigMappingMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigMappingMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigMapping unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigMappingMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigMapping edge %s", name)
}

// ConfigTaskMutation represents an operation that mutates the ConfigTask nodes in the graph.
type ConfigTaskMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	config_mapping_id               *int32
	addconfig_mapping_id            *int32
	task_index                      *int32
	addtask_index                   *int32
	name                            *string
	end_point                       *string
	method                          *string
	header                          *string
	path_params                     *string
	request_params                  *string
	request_body                    *string
	response_success_http_status    *int32
	addresponse_success_http_status *int32
	response_success_code_schema    *string
	response_message_schema         *string
	message_transformations         *string
	group_by_columns                *string
	group_by_size_limit             *int32
	addgroup_by_size_limit          *int32
	is_async                        *bool
	created_at                      *time.Time
	created_by                      *string
	updated_at                      *time.Time
	clearedFields                   map[string]struct{}
	done                            bool
	oldValue                        func(context.Context) (*ConfigTask, error)
	predicates                      []predicate.ConfigTask
}

var _ ent.Mutation = (*ConfigTaskMutation)(nil)

// configtaskOption allows management of the mutation configuration using functional options.
type configtaskOption func(*ConfigTaskMutation)

// newConfigTaskMutation creates new mutation for the ConfigTask entity.
func newConfigTaskMutation(c config, op Op, opts ...configtaskOption) *ConfigTaskMutation {
	m := &ConfigTaskMutation{
		config:        c,
		op:            op,
		typ:           TypeConfigTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConfigTaskID sets the ID field of the mutation.
func withConfigTaskID(id int) configtaskOption {
	return func(m *ConfigTaskMutation) {
		var (
			err   error
			once  sync.Once
			value *ConfigTask
		)
		m.oldValue = func(ctx context.Context) (*ConfigTask, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConfigTask.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConfigTask sets the old ConfigTask of the mutation.
func withConfigTask(node *ConfigTask) configtaskOption {
	return func(m *ConfigTaskMutation) {
		m.oldValue = func(context.Context) (*ConfigTask, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConfigTaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConfigTaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConfigTaskMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConfigTaskMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConfigTask.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetConfigMappingID sets the "config_mapping_id" field.
func (m *ConfigTaskMutation) SetConfigMappingID(i int32) {
	m.config_mapping_id = &i
	m.addconfig_mapping_id = nil
}

// ConfigMappingID returns the value of the "config_mapping_id" field in the mutation.
func (m *ConfigTaskMutation) ConfigMappingID() (r int32, exists bool) {
	v := m.config_mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConfigMappingID returns the old "config_mapping_id" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldConfigMappingID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfigMappingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfigMappingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfigMappingID: %w", err)
	}
	return oldValue.ConfigMappingID, nil
}

// AddConfigMappingID adds i to the "config_mapping_id" field.
func (m *ConfigTaskMutation) AddConfigMappingID(i int32) {
	if m.addconfig_mapping_id != nil {
		*m.addconfig_mapping_id += i
	} else {
		m.addconfig_mapping_id = &i
	}
}

// AddedConfigMappingID returns the value that was added to the "config_mapping_id" field in this mutation.
func (m *ConfigTaskMutation) AddedConfigMappingID() (r int32, exists bool) {
	v := m.addconfig_mapping_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetConfigMappingID resets all changes to the "config_mapping_id" field.
func (m *ConfigTaskMutation) ResetConfigMappingID() {
	m.config_mapping_id = nil
	m.addconfig_mapping_id = nil
}

// SetTaskIndex sets the "task_index" field.
func (m *ConfigTaskMutation) SetTaskIndex(i int32) {
	m.task_index = &i
	m.addtask_index = nil
}

// TaskIndex returns the value of the "task_index" field in the mutation.
func (m *ConfigTaskMutation) TaskIndex() (r int32, exists bool) {
	v := m.task_index
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskIndex returns the old "task_index" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldTaskIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskIndex: %w", err)
	}
	return oldValue.TaskIndex, nil
}

// AddTaskIndex adds i to the "task_index" field.
func (m *ConfigTaskMutation) AddTaskIndex(i int32) {
	if m.addtask_index != nil {
		*m.addtask_index += i
	} else {
		m.addtask_index = &i
	}
}

// AddedTaskIndex returns the value that was added to the "task_index" field in this mutation.
func (m *ConfigTaskMutation) AddedTaskIndex() (r int32, exists bool) {
	v := m.addtask_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskIndex resets all changes to the "task_index" field.
func (m *ConfigTaskMutation) ResetTaskIndex() {
	m.task_index = nil
	m.addtask_index = nil
}

// SetName sets the "name" field.
func (m *ConfigTaskMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConfigTaskMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConfigTaskMutation) ResetName() {
	m.name = nil
}

// SetEndPoint sets the "end_point" field.
func (m *ConfigTaskMutation) SetEndPoint(s string) {
	m.end_point = &s
}

// EndPoint returns the value of the "end_point" field in the mutation.
func (m *ConfigTaskMutation) EndPoint() (r string, exists bool) {
	v := m.end_point
	if v == nil {
		return
	}
	return *v, true
}

// OldEndPoint returns the old "end_point" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldEndPoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndPoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndPoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndPoint: %w", err)
	}
	return oldValue.EndPoint, nil
}

// ResetEndPoint resets all changes to the "end_point" field.
func (m *ConfigTaskMutation) ResetEndPoint() {
	m.end_point = nil
}

// SetMethod sets the "method" field.
func (m *ConfigTaskMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *ConfigTaskMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *ConfigTaskMutation) ResetMethod() {
	m.method = nil
}

// SetHeader sets the "header" field.
func (m *ConfigTaskMutation) SetHeader(s string) {
	m.header = &s
}

// Header returns the value of the "header" field in the mutation.
func (m *ConfigTaskMutation) Header() (r string, exists bool) {
	v := m.header
	if v == nil {
		return
	}
	return *v, true
}

// OldHeader returns the old "header" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldHeader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeader: %w", err)
	}
	return oldValue.Header, nil
}

// ResetHeader resets all changes to the "header" field.
func (m *ConfigTaskMutation) ResetHeader() {
	m.header = nil
}

// SetPathParams sets the "path_params" field.
func (m *ConfigTaskMutation) SetPathParams(s string) {
	m.path_params = &s
}

// PathParams returns the value of the "path_params" field in the mutation.
func (m *ConfigTaskMutation) PathParams() (r string, exists bool) {
	v := m.path_params
	if v == nil {
		return
	}
	return *v, true
}

// OldPathParams returns the old "path_params" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldPathParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPathParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPathParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPathParams: %w", err)
	}
	return oldValue.PathParams, nil
}

// ResetPathParams resets all changes to the "path_params" field.
func (m *ConfigTaskMutation) ResetPathParams() {
	m.path_params = nil
}

// SetRequestParams sets the "request_params" field.
func (m *ConfigTaskMutation) SetRequestParams(s string) {
	m.request_params = &s
}

// RequestParams returns the value of the "request_params" field in the mutation.
func (m *ConfigTaskMutation) RequestParams() (r string, exists bool) {
	v := m.request_params
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestParams returns the old "request_params" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldRequestParams(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestParams is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestParams requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestParams: %w", err)
	}
	return oldValue.RequestParams, nil
}

// ResetRequestParams resets all changes to the "request_params" field.
func (m *ConfigTaskMutation) ResetRequestParams() {
	m.request_params = nil
}

// SetRequestBody sets the "request_body" field.
func (m *ConfigTaskMutation) SetRequestBody(s string) {
	m.request_body = &s
}

// RequestBody returns the value of the "request_body" field in the mutation.
func (m *ConfigTaskMutation) RequestBody() (r string, exists bool) {
	v := m.request_body
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestBody returns the old "request_body" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldRequestBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestBody: %w", err)
	}
	return oldValue.RequestBody, nil
}

// ResetRequestBody resets all changes to the "request_body" field.
func (m *ConfigTaskMutation) ResetRequestBody() {
	m.request_body = nil
}

// SetResponseSuccessHTTPStatus sets the "response_success_http_status" field.
func (m *ConfigTaskMutation) SetResponseSuccessHTTPStatus(i int32) {
	m.response_success_http_status = &i
	m.addresponse_success_http_status = nil
}

// ResponseSuccessHTTPStatus returns the value of the "response_success_http_status" field in the mutation.
func (m *ConfigTaskMutation) ResponseSuccessHTTPStatus() (r int32, exists bool) {
	v := m.response_success_http_status
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseSuccessHTTPStatus returns the old "response_success_http_status" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldResponseSuccessHTTPStatus(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseSuccessHTTPStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseSuccessHTTPStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseSuccessHTTPStatus: %w", err)
	}
	return oldValue.ResponseSuccessHTTPStatus, nil
}

// AddResponseSuccessHTTPStatus adds i to the "response_success_http_status" field.
func (m *ConfigTaskMutation) AddResponseSuccessHTTPStatus(i int32) {
	if m.addresponse_success_http_status != nil {
		*m.addresponse_success_http_status += i
	} else {
		m.addresponse_success_http_status = &i
	}
}

// AddedResponseSuccessHTTPStatus returns the value that was added to the "response_success_http_status" field in this mutation.
func (m *ConfigTaskMutation) AddedResponseSuccessHTTPStatus() (r int32, exists bool) {
	v := m.addresponse_success_http_status
	if v == nil {
		return
	}
	return *v, true
}

// ResetResponseSuccessHTTPStatus resets all changes to the "response_success_http_status" field.
func (m *ConfigTaskMutation) ResetResponseSuccessHTTPStatus() {
	m.response_success_http_status = nil
	m.addresponse_success_http_status = nil
}

// SetResponseSuccessCodeSchema sets the "response_success_code_schema" field.
func (m *ConfigTaskMutation) SetResponseSuccessCodeSchema(s string) {
	m.response_success_code_schema = &s
}

// ResponseSuccessCodeSchema returns the value of the "response_success_code_schema" field in the mutation.
func (m *ConfigTaskMutation) ResponseSuccessCodeSchema() (r string, exists bool) {
	v := m.response_success_code_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseSuccessCodeSchema returns the old "response_success_code_schema" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldResponseSuccessCodeSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseSuccessCodeSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseSuccessCodeSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseSuccessCodeSchema: %w", err)
	}
	return oldValue.ResponseSuccessCodeSchema, nil
}

// ResetResponseSuccessCodeSchema resets all changes to the "response_success_code_schema" field.
func (m *ConfigTaskMutation) ResetResponseSuccessCodeSchema() {
	m.response_success_code_schema = nil
}

// SetResponseMessageSchema sets the "response_message_schema" field.
func (m *ConfigTaskMutation) SetResponseMessageSchema(s string) {
	m.response_message_schema = &s
}

// ResponseMessageSchema returns the value of the "response_message_schema" field in the mutation.
func (m *ConfigTaskMutation) ResponseMessageSchema() (r string, exists bool) {
	v := m.response_message_schema
	if v == nil {
		return
	}
	return *v, true
}

// OldResponseMessageSchema returns the old "response_message_schema" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldResponseMessageSchema(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponseMessageSchema is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponseMessageSchema requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponseMessageSchema: %w", err)
	}
	return oldValue.ResponseMessageSchema, nil
}

// ResetResponseMessageSchema resets all changes to the "response_message_schema" field.
func (m *ConfigTaskMutation) ResetResponseMessageSchema() {
	m.response_message_schema = nil
}

// SetMessageTransformations sets the "message_transformations" field.
func (m *ConfigTaskMutation) SetMessageTransformations(s string) {
	m.message_transformations = &s
}

// MessageTransformations returns the value of the "message_transformations" field in the mutation.
func (m *ConfigTaskMutation) MessageTransformations() (r string, exists bool) {
	v := m.message_transformations
	if v == nil {
		return
	}
	return *v, true
}

// OldMessageTransformations returns the old "message_transformations" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldMessageTransformations(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessageTransformations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessageTransformations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessageTransformations: %w", err)
	}
	return oldValue.MessageTransformations, nil
}

// ResetMessageTransformations resets all changes to the "message_transformations" field.
func (m *ConfigTaskMutation) ResetMessageTransformations() {
	m.message_transformations = nil
}

// SetGroupByColumns sets the "group_by_columns" field.
func (m *ConfigTaskMutation) SetGroupByColumns(s string) {
	m.group_by_columns = &s
}

// GroupByColumns returns the value of the "group_by_columns" field in the mutation.
func (m *ConfigTaskMutation) GroupByColumns() (r string, exists bool) {
	v := m.group_by_columns
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupByColumns returns the old "group_by_columns" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldGroupByColumns(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupByColumns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupByColumns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupByColumns: %w", err)
	}
	return oldValue.GroupByColumns, nil
}

// ResetGroupByColumns resets all changes to the "group_by_columns" field.
func (m *ConfigTaskMutation) ResetGroupByColumns() {
	m.group_by_columns = nil
}

// SetGroupBySizeLimit sets the "group_by_size_limit" field.
func (m *ConfigTaskMutation) SetGroupBySizeLimit(i int32) {
	m.group_by_size_limit = &i
	m.addgroup_by_size_limit = nil
}

// GroupBySizeLimit returns the value of the "group_by_size_limit" field in the mutation.
func (m *ConfigTaskMutation) GroupBySizeLimit() (r int32, exists bool) {
	v := m.group_by_size_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupBySizeLimit returns the old "group_by_size_limit" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldGroupBySizeLimit(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupBySizeLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupBySizeLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupBySizeLimit: %w", err)
	}
	return oldValue.GroupBySizeLimit, nil
}

// AddGroupBySizeLimit adds i to the "group_by_size_limit" field.
func (m *ConfigTaskMutation) AddGroupBySizeLimit(i int32) {
	if m.addgroup_by_size_limit != nil {
		*m.addgroup_by_size_limit += i
	} else {
		m.addgroup_by_size_limit = &i
	}
}

// AddedGroupBySizeLimit returns the value that was added to the "group_by_size_limit" field in this mutation.
func (m *ConfigTaskMutation) AddedGroupBySizeLimit() (r int32, exists bool) {
	v := m.addgroup_by_size_limit
	if v == nil {
		return
	}
	return *v, true
}

// ResetGroupBySizeLimit resets all changes to the "group_by_size_limit" field.
func (m *ConfigTaskMutation) ResetGroupBySizeLimit() {
	m.group_by_size_limit = nil
	m.addgroup_by_size_limit = nil
}

// SetIsAsync sets the "is_async" field.
func (m *ConfigTaskMutation) SetIsAsync(b bool) {
	m.is_async = &b
}

// IsAsync returns the value of the "is_async" field in the mutation.
func (m *ConfigTaskMutation) IsAsync() (r bool, exists bool) {
	v := m.is_async
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAsync returns the old "is_async" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldIsAsync(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAsync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAsync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAsync: %w", err)
	}
	return oldValue.IsAsync, nil
}

// ResetIsAsync resets all changes to the "is_async" field.
func (m *ConfigTaskMutation) ResetIsAsync() {
	m.is_async = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConfigTaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConfigTaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConfigTaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ConfigTaskMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ConfigTaskMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ConfigTaskMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConfigTaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConfigTaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ConfigTask entity.
// If the ConfigTask object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConfigTaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConfigTaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ConfigTaskMutation builder.
func (m *ConfigTaskMutation) Where(ps ...predicate.ConfigTask) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ConfigTaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ConfigTask).
func (m *ConfigTaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConfigTaskMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.config_mapping_id != nil {
		fields = append(fields, configtask.FieldConfigMappingID)
	}
	if m.task_index != nil {
		fields = append(fields, configtask.FieldTaskIndex)
	}
	if m.name != nil {
		fields = append(fields, configtask.FieldName)
	}
	if m.end_point != nil {
		fields = append(fields, configtask.FieldEndPoint)
	}
	if m.method != nil {
		fields = append(fields, configtask.FieldMethod)
	}
	if m.header != nil {
		fields = append(fields, configtask.FieldHeader)
	}
	if m.path_params != nil {
		fields = append(fields, configtask.FieldPathParams)
	}
	if m.request_params != nil {
		fields = append(fields, configtask.FieldRequestParams)
	}
	if m.request_body != nil {
		fields = append(fields, configtask.FieldRequestBody)
	}
	if m.response_success_http_status != nil {
		fields = append(fields, configtask.FieldResponseSuccessHTTPStatus)
	}
	if m.response_success_code_schema != nil {
		fields = append(fields, configtask.FieldResponseSuccessCodeSchema)
	}
	if m.response_message_schema != nil {
		fields = append(fields, configtask.FieldResponseMessageSchema)
	}
	if m.message_transformations != nil {
		fields = append(fields, configtask.FieldMessageTransformations)
	}
	if m.group_by_columns != nil {
		fields = append(fields, configtask.FieldGroupByColumns)
	}
	if m.group_by_size_limit != nil {
		fields = append(fields, configtask.FieldGroupBySizeLimit)
	}
	if m.is_async != nil {
		fields = append(fields, configtask.FieldIsAsync)
	}
	if m.created_at != nil {
		fields = append(fields, configtask.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, configtask.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, configtask.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConfigTaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case configtask.FieldConfigMappingID:
		return m.ConfigMappingID()
	case configtask.FieldTaskIndex:
		return m.TaskIndex()
	case configtask.FieldName:
		return m.Name()
	case configtask.FieldEndPoint:
		return m.EndPoint()
	case configtask.FieldMethod:
		return m.Method()
	case configtask.FieldHeader:
		return m.Header()
	case configtask.FieldPathParams:
		return m.PathParams()
	case configtask.FieldRequestParams:
		return m.RequestParams()
	case configtask.FieldRequestBody:
		return m.RequestBody()
	case configtask.FieldResponseSuccessHTTPStatus:
		return m.ResponseSuccessHTTPStatus()
	case configtask.FieldResponseSuccessCodeSchema:
		return m.ResponseSuccessCodeSchema()
	case configtask.FieldResponseMessageSchema:
		return m.ResponseMessageSchema()
	case configtask.FieldMessageTransformations:
		return m.MessageTransformations()
	case configtask.FieldGroupByColumns:
		return m.GroupByColumns()
	case configtask.FieldGroupBySizeLimit:
		return m.GroupBySizeLimit()
	case configtask.FieldIsAsync:
		return m.IsAsync()
	case configtask.FieldCreatedAt:
		return m.CreatedAt()
	case configtask.FieldCreatedBy:
		return m.CreatedBy()
	case configtask.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConfigTaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case configtask.FieldConfigMappingID:
		return m.OldConfigMappingID(ctx)
	case configtask.FieldTaskIndex:
		return m.OldTaskIndex(ctx)
	case configtask.FieldName:
		return m.OldName(ctx)
	case configtask.FieldEndPoint:
		return m.OldEndPoint(ctx)
	case configtask.FieldMethod:
		return m.OldMethod(ctx)
	case configtask.FieldHeader:
		return m.OldHeader(ctx)
	case configtask.FieldPathParams:
		return m.OldPathParams(ctx)
	case configtask.FieldRequestParams:
		return m.OldRequestParams(ctx)
	case configtask.FieldRequestBody:
		return m.OldRequestBody(ctx)
	case configtask.FieldResponseSuccessHTTPStatus:
		return m.OldResponseSuccessHTTPStatus(ctx)
	case configtask.FieldResponseSuccessCodeSchema:
		return m.OldResponseSuccessCodeSchema(ctx)
	case configtask.FieldResponseMessageSchema:
		return m.OldResponseMessageSchema(ctx)
	case configtask.FieldMessageTransformations:
		return m.OldMessageTransformations(ctx)
	case configtask.FieldGroupByColumns:
		return m.OldGroupByColumns(ctx)
	case configtask.FieldGroupBySizeLimit:
		return m.OldGroupBySizeLimit(ctx)
	case configtask.FieldIsAsync:
		return m.OldIsAsync(ctx)
	case configtask.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case configtask.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case configtask.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConfigTask field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigTaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case configtask.FieldConfigMappingID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfigMappingID(v)
		return nil
	case configtask.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskIndex(v)
		return nil
	case configtask.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case configtask.FieldEndPoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndPoint(v)
		return nil
	case configtask.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case configtask.FieldHeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeader(v)
		return nil
	case configtask.FieldPathParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPathParams(v)
		return nil
	case configtask.FieldRequestParams:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestParams(v)
		return nil
	case configtask.FieldRequestBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestBody(v)
		return nil
	case configtask.FieldResponseSuccessHTTPStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseSuccessHTTPStatus(v)
		return nil
	case configtask.FieldResponseSuccessCodeSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseSuccessCodeSchema(v)
		return nil
	case configtask.FieldResponseMessageSchema:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponseMessageSchema(v)
		return nil
	case configtask.FieldMessageTransformations:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessageTransformations(v)
		return nil
	case configtask.FieldGroupByColumns:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupByColumns(v)
		return nil
	case configtask.FieldGroupBySizeLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupBySizeLimit(v)
		return nil
	case configtask.FieldIsAsync:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAsync(v)
		return nil
	case configtask.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case configtask.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case configtask.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigTask field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConfigTaskMutation) AddedFields() []string {
	var fields []string
	if m.addconfig_mapping_id != nil {
		fields = append(fields, configtask.FieldConfigMappingID)
	}
	if m.addtask_index != nil {
		fields = append(fields, configtask.FieldTaskIndex)
	}
	if m.addresponse_success_http_status != nil {
		fields = append(fields, configtask.FieldResponseSuccessHTTPStatus)
	}
	if m.addgroup_by_size_limit != nil {
		fields = append(fields, configtask.FieldGroupBySizeLimit)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConfigTaskMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case configtask.FieldConfigMappingID:
		return m.AddedConfigMappingID()
	case configtask.FieldTaskIndex:
		return m.AddedTaskIndex()
	case configtask.FieldResponseSuccessHTTPStatus:
		return m.AddedResponseSuccessHTTPStatus()
	case configtask.FieldGroupBySizeLimit:
		return m.AddedGroupBySizeLimit()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConfigTaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	case configtask.FieldConfigMappingID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddConfigMappingID(v)
		return nil
	case configtask.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskIndex(v)
		return nil
	case configtask.FieldResponseSuccessHTTPStatus:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddResponseSuccessHTTPStatus(v)
		return nil
	case configtask.FieldGroupBySizeLimit:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddGroupBySizeLimit(v)
		return nil
	}
	return fmt.Errorf("unknown ConfigTask numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConfigTaskMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConfigTaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConfigTaskMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConfigTask nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConfigTaskMutation) ResetField(name string) error {
	switch name {
	case configtask.FieldConfigMappingID:
		m.ResetConfigMappingID()
		return nil
	case configtask.FieldTaskIndex:
		m.ResetTaskIndex()
		return nil
	case configtask.FieldName:
		m.ResetName()
		return nil
	case configtask.FieldEndPoint:
		m.ResetEndPoint()
		return nil
	case configtask.FieldMethod:
		m.ResetMethod()
		return nil
	case configtask.FieldHeader:
		m.ResetHeader()
		return nil
	case configtask.FieldPathParams:
		m.ResetPathParams()
		return nil
	case configtask.FieldRequestParams:
		m.ResetRequestParams()
		return nil
	case configtask.FieldRequestBody:
		m.ResetRequestBody()
		return nil
	case configtask.FieldResponseSuccessHTTPStatus:
		m.ResetResponseSuccessHTTPStatus()
		return nil
	case configtask.FieldResponseSuccessCodeSchema:
		m.ResetResponseSuccessCodeSchema()
		return nil
	case configtask.FieldResponseMessageSchema:
		m.ResetResponseMessageSchema()
		return nil
	case configtask.FieldMessageTransformations:
		m.ResetMessageTransformations()
		return nil
	case configtask.FieldGroupByColumns:
		m.ResetGroupByColumns()
		return nil
	case configtask.FieldGroupBySizeLimit:
		m.ResetGroupBySizeLimit()
		return nil
	case configtask.FieldIsAsync:
		m.ResetIsAsync()
		return nil
	case configtask.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case configtask.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case configtask.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConfigTask field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConfigTaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConfigTaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConfigTaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConfigTaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConfigTaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConfigTaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConfigTaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ConfigTask unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConfigTaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ConfigTask edge %s", name)
}

// FpsClientMutation represents an operation that mutates the FpsClient nodes in the graph.
type FpsClientMutation struct {
	config
	op              Op
	typ             string
	id              *int
	client_id       *int32
	addclient_id    *int32
	name            *string
	description     *string
	sample_file_url *string
	created_at      *time.Time
	created_by      *string
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*FpsClient, error)
	predicates      []predicate.FpsClient
}

var _ ent.Mutation = (*FpsClientMutation)(nil)

// fpsclientOption allows management of the mutation configuration using functional options.
type fpsclientOption func(*FpsClientMutation)

// newFpsClientMutation creates new mutation for the FpsClient entity.
func newFpsClientMutation(c config, op Op, opts ...fpsclientOption) *FpsClientMutation {
	m := &FpsClientMutation{
		config:        c,
		op:            op,
		typ:           TypeFpsClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFpsClientID sets the ID field of the mutation.
func withFpsClientID(id int) fpsclientOption {
	return func(m *FpsClientMutation) {
		var (
			err   error
			once  sync.Once
			value *FpsClient
		)
		m.oldValue = func(ctx context.Context) (*FpsClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FpsClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFpsClient sets the old FpsClient of the mutation.
func withFpsClient(node *FpsClient) fpsclientOption {
	return func(m *FpsClientMutation) {
		m.oldValue = func(context.Context) (*FpsClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FpsClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FpsClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FpsClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FpsClientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FpsClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *FpsClientMutation) SetClientID(i int32) {
	m.client_id = &i
	m.addclient_id = nil
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *FpsClientMutation) ClientID() (r int32, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldClientID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// AddClientID adds i to the "client_id" field.
func (m *FpsClientMutation) AddClientID(i int32) {
	if m.addclient_id != nil {
		*m.addclient_id += i
	} else {
		m.addclient_id = &i
	}
}

// AddedClientID returns the value that was added to the "client_id" field in this mutation.
func (m *FpsClientMutation) AddedClientID() (r int32, exists bool) {
	v := m.addclient_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientID resets all changes to the "client_id" field.
func (m *FpsClientMutation) ResetClientID() {
	m.client_id = nil
	m.addclient_id = nil
}

// SetName sets the "name" field.
func (m *FpsClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FpsClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FpsClientMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *FpsClientMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *FpsClientMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *FpsClientMutation) ResetDescription() {
	m.description = nil
}

// SetSampleFileURL sets the "sample_file_url" field.
func (m *FpsClientMutation) SetSampleFileURL(s string) {
	m.sample_file_url = &s
}

// SampleFileURL returns the value of the "sample_file_url" field in the mutation.
func (m *FpsClientMutation) SampleFileURL() (r string, exists bool) {
	v := m.sample_file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSampleFileURL returns the old "sample_file_url" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldSampleFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSampleFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSampleFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSampleFileURL: %w", err)
	}
	return oldValue.SampleFileURL, nil
}

// ResetSampleFileURL resets all changes to the "sample_file_url" field.
func (m *FpsClientMutation) ResetSampleFileURL() {
	m.sample_file_url = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FpsClientMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FpsClientMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FpsClientMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FpsClientMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FpsClientMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FpsClientMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FpsClientMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FpsClientMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the FpsClient entity.
// If the FpsClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FpsClientMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FpsClientMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the FpsClientMutation builder.
func (m *FpsClientMutation) Where(ps ...predicate.FpsClient) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FpsClientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FpsClient).
func (m *FpsClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FpsClientMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.client_id != nil {
		fields = append(fields, fpsclient.FieldClientID)
	}
	if m.name != nil {
		fields = append(fields, fpsclient.FieldName)
	}
	if m.description != nil {
		fields = append(fields, fpsclient.FieldDescription)
	}
	if m.sample_file_url != nil {
		fields = append(fields, fpsclient.FieldSampleFileURL)
	}
	if m.created_at != nil {
		fields = append(fields, fpsclient.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, fpsclient.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, fpsclient.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FpsClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fpsclient.FieldClientID:
		return m.ClientID()
	case fpsclient.FieldName:
		return m.Name()
	case fpsclient.FieldDescription:
		return m.Description()
	case fpsclient.FieldSampleFileURL:
		return m.SampleFileURL()
	case fpsclient.FieldCreatedAt:
		return m.CreatedAt()
	case fpsclient.FieldCreatedBy:
		return m.CreatedBy()
	case fpsclient.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FpsClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fpsclient.FieldClientID:
		return m.OldClientID(ctx)
	case fpsclient.FieldName:
		return m.OldName(ctx)
	case fpsclient.FieldDescription:
		return m.OldDescription(ctx)
	case fpsclient.FieldSampleFileURL:
		return m.OldSampleFileURL(ctx)
	case fpsclient.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case fpsclient.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case fpsclient.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown FpsClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FpsClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fpsclient.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case fpsclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case fpsclient.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case fpsclient.FieldSampleFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSampleFileURL(v)
		return nil
	case fpsclient.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case fpsclient.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case fpsclient.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown FpsClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FpsClientMutation) AddedFields() []string {
	var fields []string
	if m.addclient_id != nil {
		fields = append(fields, fpsclient.FieldClientID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FpsClientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case fpsclient.FieldClientID:
		return m.AddedClientID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FpsClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case fpsclient.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientID(v)
		return nil
	}
	return fmt.Errorf("unknown FpsClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FpsClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FpsClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FpsClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FpsClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FpsClientMutation) ResetField(name string) error {
	switch name {
	case fpsclient.FieldClientID:
		m.ResetClientID()
		return nil
	case fpsclient.FieldName:
		m.ResetName()
		return nil
	case fpsclient.FieldDescription:
		m.ResetDescription()
		return nil
	case fpsclient.FieldSampleFileURL:
		m.ResetSampleFileURL()
		return nil
	case fpsclient.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case fpsclient.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case fpsclient.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown FpsClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FpsClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FpsClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FpsClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FpsClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FpsClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FpsClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FpsClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown FpsClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FpsClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown FpsClient edge %s", name)
}

// ProcessingFileMutation represents an operation that mutates the ProcessingFile nodes in the graph.
type ProcessingFileMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	client_id                *int32
	addclient_id             *int32
	display_name             *string
	ext_file_request         *string
	file_url                 *string
	result_file_url          *string
	status                   *int16
	addstatus                *int16
	file_parameters          *string
	seller_id                *int32
	addseller_id             *int32
	total_mapping            *int32
	addtotal_mapping         *int32
	need_group_row           *bool
	stats_total_row          *int32
	addstats_total_row       *int32
	stats_total_processed    *int32
	addstats_total_processed *int32
	stats_total_success      *int32
	addstats_total_success   *int32
	error_display            *string
	tenant_id                *string
	merchant_id              *string
	created_at               *time.Time
	created_by               *string
	updated_at               *time.Time
	clearedFields            map[string]struct{}
	done                     bool
	oldValue                 func(context.Context) (*ProcessingFile, error)
	predicates               []predicate.ProcessingFile
}

var _ ent.Mutation = (*ProcessingFileMutation)(nil)

// processingfileOption allows management of the mutation configuration using functional options.
type processingfileOption func(*ProcessingFileMutation)

// newProcessingFileMutation creates new mutation for the ProcessingFile entity.
func newProcessingFileMutation(c config, op Op, opts ...processingfileOption) *ProcessingFileMutation {
	m := &ProcessingFileMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessingFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessingFileID sets the ID field of the mutation.
func withProcessingFileID(id int) processingfileOption {
	return func(m *ProcessingFileMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessingFile
		)
		m.oldValue = func(ctx context.Context) (*ProcessingFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessingFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessingFile sets the old ProcessingFile of the mutation.
func withProcessingFile(node *ProcessingFile) processingfileOption {
	return func(m *ProcessingFileMutation) {
		m.oldValue = func(context.Context) (*ProcessingFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessingFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessingFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessingFileMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessingFileMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessingFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetClientID sets the "client_id" field.
func (m *ProcessingFileMutation) SetClientID(i int32) {
	m.client_id = &i
	m.addclient_id = nil
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *ProcessingFileMutation) ClientID() (r int32, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldClientID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// AddClientID adds i to the "client_id" field.
func (m *ProcessingFileMutation) AddClientID(i int32) {
	if m.addclient_id != nil {
		*m.addclient_id += i
	} else {
		m.addclient_id = &i
	}
}

// AddedClientID returns the value that was added to the "client_id" field in this mutation.
func (m *ProcessingFileMutation) AddedClientID() (r int32, exists bool) {
	v := m.addclient_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetClientID resets all changes to the "client_id" field.
func (m *ProcessingFileMutation) ResetClientID() {
	m.client_id = nil
	m.addclient_id = nil
}

// SetDisplayName sets the "display_name" field.
func (m *ProcessingFileMutation) SetDisplayName(s string) {
	m.display_name = &s
}

// DisplayName returns the value of the "display_name" field in the mutation.
func (m *ProcessingFileMutation) DisplayName() (r string, exists bool) {
	v := m.display_name
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplayName returns the old "display_name" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldDisplayName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplayName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplayName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplayName: %w", err)
	}
	return oldValue.DisplayName, nil
}

// ResetDisplayName resets all changes to the "display_name" field.
func (m *ProcessingFileMutation) ResetDisplayName() {
	m.display_name = nil
}

// SetExtFileRequest sets the "ext_file_request" field.
func (m *ProcessingFileMutation) SetExtFileRequest(s string) {
	m.ext_file_request = &s
}

// ExtFileRequest returns the value of the "ext_file_request" field in the mutation.
func (m *ProcessingFileMutation) ExtFileRequest() (r string, exists bool) {
	v := m.ext_file_request
	if v == nil {
		return
	}
	return *v, true
}

// OldExtFileRequest returns the old "ext_file_request" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldExtFileRequest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtFileRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtFileRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtFileRequest: %w", err)
	}
	return oldValue.ExtFileRequest, nil
}

// ClearExtFileRequest clears the value of the "ext_file_request" field.
func (m *ProcessingFileMutation) ClearExtFileRequest() {
	m.ext_file_request = nil
	m.clearedFields[processingfile.FieldExtFileRequest] = struct{}{}
}

// ExtFileRequestCleared returns if the "ext_file_request" field was cleared in this mutation.
func (m *ProcessingFileMutation) ExtFileRequestCleared() bool {
	_, ok := m.clearedFields[processingfile.FieldExtFileRequest]
	return ok
}

// ResetExtFileRequest resets all changes to the "ext_file_request" field.
func (m *ProcessingFileMutation) ResetExtFileRequest() {
	m.ext_file_request = nil
	delete(m.clearedFields, processingfile.FieldExtFileRequest)
}

// SetFileURL sets the "file_url" field.
func (m *ProcessingFileMutation) SetFileURL(s string) {
	m.file_url = &s
}

// FileURL returns the value of the "file_url" field in the mutation.
func (m *ProcessingFileMutation) FileURL() (r string, exists bool) {
	v := m.file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldFileURL returns the old "file_url" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileURL: %w", err)
	}
	return oldValue.FileURL, nil
}

// ResetFileURL resets all changes to the "file_url" field.
func (m *ProcessingFileMutation) ResetFileURL() {
	m.file_url = nil
}

// SetResultFileURL sets the "result_file_url" field.
func (m *ProcessingFileMutation) SetResultFileURL(s string) {
	m.result_file_url = &s
}

// ResultFileURL returns the value of the "result_file_url" field in the mutation.
func (m *ProcessingFileMutation) ResultFileURL() (r string, exists bool) {
	v := m.result_file_url
	if v == nil {
		return
	}
	return *v, true
}

// OldResultFileURL returns the old "result_file_url" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldResultFileURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultFileURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultFileURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultFileURL: %w", err)
	}
	return oldValue.ResultFileURL, nil
}

// ResetResultFileURL resets all changes to the "result_file_url" field.
func (m *ProcessingFileMutation) ResetResultFileURL() {
	m.result_file_url = nil
}

// SetStatus sets the "status" field.
func (m *ProcessingFileMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessingFileMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProcessingFileMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProcessingFileMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessingFileMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetFileParameters sets the "file_parameters" field.
func (m *ProcessingFileMutation) SetFileParameters(s string) {
	m.file_parameters = &s
}

// FileParameters returns the value of the "file_parameters" field in the mutation.
func (m *ProcessingFileMutation) FileParameters() (r string, exists bool) {
	v := m.file_parameters
	if v == nil {
		return
	}
	return *v, true
}

// OldFileParameters returns the old "file_parameters" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldFileParameters(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileParameters is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileParameters requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileParameters: %w", err)
	}
	return oldValue.FileParameters, nil
}

// ResetFileParameters resets all changes to the "file_parameters" field.
func (m *ProcessingFileMutation) ResetFileParameters() {
	m.file_parameters = nil
}

// SetSellerID sets the "seller_id" field.
func (m *ProcessingFileMutation) SetSellerID(i int32) {
	m.seller_id = &i
	m.addseller_id = nil
}

// SellerID returns the value of the "seller_id" field in the mutation.
func (m *ProcessingFileMutation) SellerID() (r int32, exists bool) {
	v := m.seller_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSellerID returns the old "seller_id" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldSellerID(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSellerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSellerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSellerID: %w", err)
	}
	return oldValue.SellerID, nil
}

// AddSellerID adds i to the "seller_id" field.
func (m *ProcessingFileMutation) AddSellerID(i int32) {
	if m.addseller_id != nil {
		*m.addseller_id += i
	} else {
		m.addseller_id = &i
	}
}

// AddedSellerID returns the value that was added to the "seller_id" field in this mutation.
func (m *ProcessingFileMutation) AddedSellerID() (r int32, exists bool) {
	v := m.addseller_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetSellerID resets all changes to the "seller_id" field.
func (m *ProcessingFileMutation) ResetSellerID() {
	m.seller_id = nil
	m.addseller_id = nil
}

// SetTotalMapping sets the "total_mapping" field.
func (m *ProcessingFileMutation) SetTotalMapping(i int32) {
	m.total_mapping = &i
	m.addtotal_mapping = nil
}

// TotalMapping returns the value of the "total_mapping" field in the mutation.
func (m *ProcessingFileMutation) TotalMapping() (r int32, exists bool) {
	v := m.total_mapping
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalMapping returns the old "total_mapping" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldTotalMapping(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalMapping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalMapping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalMapping: %w", err)
	}
	return oldValue.TotalMapping, nil
}

// AddTotalMapping adds i to the "total_mapping" field.
func (m *ProcessingFileMutation) AddTotalMapping(i int32) {
	if m.addtotal_mapping != nil {
		*m.addtotal_mapping += i
	} else {
		m.addtotal_mapping = &i
	}
}

// AddedTotalMapping returns the value that was added to the "total_mapping" field in this mutation.
func (m *ProcessingFileMutation) AddedTotalMapping() (r int32, exists bool) {
	v := m.addtotal_mapping
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalMapping resets all changes to the "total_mapping" field.
func (m *ProcessingFileMutation) ResetTotalMapping() {
	m.total_mapping = nil
	m.addtotal_mapping = nil
}

// SetNeedGroupRow sets the "need_group_row" field.
func (m *ProcessingFileMutation) SetNeedGroupRow(b bool) {
	m.need_group_row = &b
}

// NeedGroupRow returns the value of the "need_group_row" field in the mutation.
func (m *ProcessingFileMutation) NeedGroupRow() (r bool, exists bool) {
	v := m.need_group_row
	if v == nil {
		return
	}
	return *v, true
}

// OldNeedGroupRow returns the old "need_group_row" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldNeedGroupRow(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNeedGroupRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNeedGroupRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNeedGroupRow: %w", err)
	}
	return oldValue.NeedGroupRow, nil
}

// ResetNeedGroupRow resets all changes to the "need_group_row" field.
func (m *ProcessingFileMutation) ResetNeedGroupRow() {
	m.need_group_row = nil
}

// SetStatsTotalRow sets the "stats_total_row" field.
func (m *ProcessingFileMutation) SetStatsTotalRow(i int32) {
	m.stats_total_row = &i
	m.addstats_total_row = nil
}

// StatsTotalRow returns the value of the "stats_total_row" field in the mutation.
func (m *ProcessingFileMutation) StatsTotalRow() (r int32, exists bool) {
	v := m.stats_total_row
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTotalRow returns the old "stats_total_row" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldStatsTotalRow(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTotalRow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTotalRow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTotalRow: %w", err)
	}
	return oldValue.StatsTotalRow, nil
}

// AddStatsTotalRow adds i to the "stats_total_row" field.
func (m *ProcessingFileMutation) AddStatsTotalRow(i int32) {
	if m.addstats_total_row != nil {
		*m.addstats_total_row += i
	} else {
		m.addstats_total_row = &i
	}
}

// AddedStatsTotalRow returns the value that was added to the "stats_total_row" field in this mutation.
func (m *ProcessingFileMutation) AddedStatsTotalRow() (r int32, exists bool) {
	v := m.addstats_total_row
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatsTotalRow resets all changes to the "stats_total_row" field.
func (m *ProcessingFileMutation) ResetStatsTotalRow() {
	m.stats_total_row = nil
	m.addstats_total_row = nil
}

// SetStatsTotalProcessed sets the "stats_total_processed" field.
func (m *ProcessingFileMutation) SetStatsTotalProcessed(i int32) {
	m.stats_total_processed = &i
	m.addstats_total_processed = nil
}

// StatsTotalProcessed returns the value of the "stats_total_processed" field in the mutation.
func (m *ProcessingFileMutation) StatsTotalProcessed() (r int32, exists bool) {
	v := m.stats_total_processed
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTotalProcessed returns the old "stats_total_processed" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldStatsTotalProcessed(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTotalProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTotalProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTotalProcessed: %w", err)
	}
	return oldValue.StatsTotalProcessed, nil
}

// AddStatsTotalProcessed adds i to the "stats_total_processed" field.
func (m *ProcessingFileMutation) AddStatsTotalProcessed(i int32) {
	if m.addstats_total_processed != nil {
		*m.addstats_total_processed += i
	} else {
		m.addstats_total_processed = &i
	}
}

// AddedStatsTotalProcessed returns the value that was added to the "stats_total_processed" field in this mutation.
func (m *ProcessingFileMutation) AddedStatsTotalProcessed() (r int32, exists bool) {
	v := m.addstats_total_processed
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatsTotalProcessed resets all changes to the "stats_total_processed" field.
func (m *ProcessingFileMutation) ResetStatsTotalProcessed() {
	m.stats_total_processed = nil
	m.addstats_total_processed = nil
}

// SetStatsTotalSuccess sets the "stats_total_success" field.
func (m *ProcessingFileMutation) SetStatsTotalSuccess(i int32) {
	m.stats_total_success = &i
	m.addstats_total_success = nil
}

// StatsTotalSuccess returns the value of the "stats_total_success" field in the mutation.
func (m *ProcessingFileMutation) StatsTotalSuccess() (r int32, exists bool) {
	v := m.stats_total_success
	if v == nil {
		return
	}
	return *v, true
}

// OldStatsTotalSuccess returns the old "stats_total_success" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldStatsTotalSuccess(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatsTotalSuccess is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatsTotalSuccess requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatsTotalSuccess: %w", err)
	}
	return oldValue.StatsTotalSuccess, nil
}

// AddStatsTotalSuccess adds i to the "stats_total_success" field.
func (m *ProcessingFileMutation) AddStatsTotalSuccess(i int32) {
	if m.addstats_total_success != nil {
		*m.addstats_total_success += i
	} else {
		m.addstats_total_success = &i
	}
}

// AddedStatsTotalSuccess returns the value that was added to the "stats_total_success" field in this mutation.
func (m *ProcessingFileMutation) AddedStatsTotalSuccess() (r int32, exists bool) {
	v := m.addstats_total_success
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatsTotalSuccess resets all changes to the "stats_total_success" field.
func (m *ProcessingFileMutation) ResetStatsTotalSuccess() {
	m.stats_total_success = nil
	m.addstats_total_success = nil
}

// SetErrorDisplay sets the "error_display" field.
func (m *ProcessingFileMutation) SetErrorDisplay(s string) {
	m.error_display = &s
}

// ErrorDisplay returns the value of the "error_display" field in the mutation.
func (m *ProcessingFileMutation) ErrorDisplay() (r string, exists bool) {
	v := m.error_display
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDisplay returns the old "error_display" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldErrorDisplay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDisplay: %w", err)
	}
	return oldValue.ErrorDisplay, nil
}

// ResetErrorDisplay resets all changes to the "error_display" field.
func (m *ProcessingFileMutation) ResetErrorDisplay() {
	m.error_display = nil
}

// SetTenantID sets the "tenant_id" field.
func (m *ProcessingFileMutation) SetTenantID(s string) {
	m.tenant_id = &s
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProcessingFileMutation) TenantID() (r string, exists bool) {
	v := m.tenant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldTenantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProcessingFileMutation) ResetTenantID() {
	m.tenant_id = nil
}

// SetMerchantID sets the "merchant_id" field.
func (m *ProcessingFileMutation) SetMerchantID(s string) {
	m.merchant_id = &s
}

// MerchantID returns the value of the "merchant_id" field in the mutation.
func (m *ProcessingFileMutation) MerchantID() (r string, exists bool) {
	v := m.merchant_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMerchantID returns the old "merchant_id" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldMerchantID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMerchantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMerchantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMerchantID: %w", err)
	}
	return oldValue.MerchantID, nil
}

// ResetMerchantID resets all changes to the "merchant_id" field.
func (m *ProcessingFileMutation) ResetMerchantID() {
	m.merchant_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessingFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessingFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessingFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *ProcessingFileMutation) SetCreatedBy(s string) {
	m.created_by = &s
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *ProcessingFileMutation) CreatedBy() (r string, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldCreatedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *ProcessingFileMutation) ResetCreatedBy() {
	m.created_by = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessingFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessingFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessingFile entity.
// If the ProcessingFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessingFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessingFileMutation builder.
func (m *ProcessingFileMutation) Where(ps ...predicate.ProcessingFile) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcessingFileMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcessingFile).
func (m *ProcessingFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessingFileMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.client_id != nil {
		fields = append(fields, processingfile.FieldClientID)
	}
	if m.display_name != nil {
		fields = append(fields, processingfile.FieldDisplayName)
	}
	if m.ext_file_request != nil {
		fields = append(fields, processingfile.FieldExtFileRequest)
	}
	if m.file_url != nil {
		fields = append(fields, processingfile.FieldFileURL)
	}
	if m.result_file_url != nil {
		fields = append(fields, processingfile.FieldResultFileURL)
	}
	if m.status != nil {
		fields = append(fields, processingfile.FieldStatus)
	}
	if m.file_parameters != nil {
		fields = append(fields, processingfile.FieldFileParameters)
	}
	if m.seller_id != nil {
		fields = append(fields, processingfile.FieldSellerID)
	}
	if m.total_mapping != nil {
		fields = append(fields, processingfile.FieldTotalMapping)
	}
	if m.need_group_row != nil {
		fields = append(fields, processingfile.FieldNeedGroupRow)
	}
	if m.stats_total_row != nil {
		fields = append(fields, processingfile.FieldStatsTotalRow)
	}
	if m.stats_total_processed != nil {
		fields = append(fields, processingfile.FieldStatsTotalProcessed)
	}
	if m.stats_total_success != nil {
		fields = append(fields, processingfile.FieldStatsTotalSuccess)
	}
	if m.error_display != nil {
		fields = append(fields, processingfile.FieldErrorDisplay)
	}
	if m.tenant_id != nil {
		fields = append(fields, processingfile.FieldTenantID)
	}
	if m.merchant_id != nil {
		fields = append(fields, processingfile.FieldMerchantID)
	}
	if m.created_at != nil {
		fields = append(fields, processingfile.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, processingfile.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, processingfile.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessingFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processingfile.FieldClientID:
		return m.ClientID()
	case processingfile.FieldDisplayName:
		return m.DisplayName()
	case processingfile.FieldExtFileRequest:
		return m.ExtFileRequest()
	case processingfile.FieldFileURL:
		return m.FileURL()
	case processingfile.FieldResultFileURL:
		return m.ResultFileURL()
	case processingfile.FieldStatus:
		return m.Status()
	case processingfile.FieldFileParameters:
		return m.FileParameters()
	case processingfile.FieldSellerID:
		return m.SellerID()
	case processingfile.FieldTotalMapping:
		return m.TotalMapping()
	case processingfile.FieldNeedGroupRow:
		return m.NeedGroupRow()
	case processingfile.FieldStatsTotalRow:
		return m.StatsTotalRow()
	case processingfile.FieldStatsTotalProcessed:
		return m.StatsTotalProcessed()
	case processingfile.FieldStatsTotalSuccess:
		return m.StatsTotalSuccess()
	case processingfile.FieldErrorDisplay:
		return m.ErrorDisplay()
	case processingfile.FieldTenantID:
		return m.TenantID()
	case processingfile.FieldMerchantID:
		return m.MerchantID()
	case processingfile.FieldCreatedAt:
		return m.CreatedAt()
	case processingfile.FieldCreatedBy:
		return m.CreatedBy()
	case processingfile.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessingFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processingfile.FieldClientID:
		return m.OldClientID(ctx)
	case processingfile.FieldDisplayName:
		return m.OldDisplayName(ctx)
	case processingfile.FieldExtFileRequest:
		return m.OldExtFileRequest(ctx)
	case processingfile.FieldFileURL:
		return m.OldFileURL(ctx)
	case processingfile.FieldResultFileURL:
		return m.OldResultFileURL(ctx)
	case processingfile.FieldStatus:
		return m.OldStatus(ctx)
	case processingfile.FieldFileParameters:
		return m.OldFileParameters(ctx)
	case processingfile.FieldSellerID:
		return m.OldSellerID(ctx)
	case processingfile.FieldTotalMapping:
		return m.OldTotalMapping(ctx)
	case processingfile.FieldNeedGroupRow:
		return m.OldNeedGroupRow(ctx)
	case processingfile.FieldStatsTotalRow:
		return m.OldStatsTotalRow(ctx)
	case processingfile.FieldStatsTotalProcessed:
		return m.OldStatsTotalProcessed(ctx)
	case processingfile.FieldStatsTotalSuccess:
		return m.OldStatsTotalSuccess(ctx)
	case processingfile.FieldErrorDisplay:
		return m.OldErrorDisplay(ctx)
	case processingfile.FieldTenantID:
		return m.OldTenantID(ctx)
	case processingfile.FieldMerchantID:
		return m.OldMerchantID(ctx)
	case processingfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processingfile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case processingfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessingFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processingfile.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case processingfile.FieldDisplayName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplayName(v)
		return nil
	case processingfile.FieldExtFileRequest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtFileRequest(v)
		return nil
	case processingfile.FieldFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileURL(v)
		return nil
	case processingfile.FieldResultFileURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultFileURL(v)
		return nil
	case processingfile.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processingfile.FieldFileParameters:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileParameters(v)
		return nil
	case processingfile.FieldSellerID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSellerID(v)
		return nil
	case processingfile.FieldTotalMapping:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalMapping(v)
		return nil
	case processingfile.FieldNeedGroupRow:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNeedGroupRow(v)
		return nil
	case processingfile.FieldStatsTotalRow:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTotalRow(v)
		return nil
	case processingfile.FieldStatsTotalProcessed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTotalProcessed(v)
		return nil
	case processingfile.FieldStatsTotalSuccess:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatsTotalSuccess(v)
		return nil
	case processingfile.FieldErrorDisplay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDisplay(v)
		return nil
	case processingfile.FieldTenantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case processingfile.FieldMerchantID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMerchantID(v)
		return nil
	case processingfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processingfile.FieldCreatedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case processingfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessingFileMutation) AddedFields() []string {
	var fields []string
	if m.addclient_id != nil {
		fields = append(fields, processingfile.FieldClientID)
	}
	if m.addstatus != nil {
		fields = append(fields, processingfile.FieldStatus)
	}
	if m.addseller_id != nil {
		fields = append(fields, processingfile.FieldSellerID)
	}
	if m.addtotal_mapping != nil {
		fields = append(fields, processingfile.FieldTotalMapping)
	}
	if m.addstats_total_row != nil {
		fields = append(fields, processingfile.FieldStatsTotalRow)
	}
	if m.addstats_total_processed != nil {
		fields = append(fields, processingfile.FieldStatsTotalProcessed)
	}
	if m.addstats_total_success != nil {
		fields = append(fields, processingfile.FieldStatsTotalSuccess)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessingFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processingfile.FieldClientID:
		return m.AddedClientID()
	case processingfile.FieldStatus:
		return m.AddedStatus()
	case processingfile.FieldSellerID:
		return m.AddedSellerID()
	case processingfile.FieldTotalMapping:
		return m.AddedTotalMapping()
	case processingfile.FieldStatsTotalRow:
		return m.AddedStatsTotalRow()
	case processingfile.FieldStatsTotalProcessed:
		return m.AddedStatsTotalProcessed()
	case processingfile.FieldStatsTotalSuccess:
		return m.AddedStatsTotalSuccess()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processingfile.FieldClientID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClientID(v)
		return nil
	case processingfile.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case processingfile.FieldSellerID:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSellerID(v)
		return nil
	case processingfile.FieldTotalMapping:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalMapping(v)
		return nil
	case processingfile.FieldStatsTotalRow:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatsTotalRow(v)
		return nil
	case processingfile.FieldStatsTotalProcessed:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatsTotalProcessed(v)
		return nil
	case processingfile.FieldStatsTotalSuccess:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatsTotalSuccess(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessingFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processingfile.FieldExtFileRequest) {
		fields = append(fields, processingfile.FieldExtFileRequest)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessingFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessingFileMutation) ClearField(name string) error {
	switch name {
	case processingfile.FieldExtFileRequest:
		m.ClearExtFileRequest()
		return nil
	}
	return fmt.Errorf("unknown ProcessingFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessingFileMutation) ResetField(name string) error {
	switch name {
	case processingfile.FieldClientID:
		m.ResetClientID()
		return nil
	case processingfile.FieldDisplayName:
		m.ResetDisplayName()
		return nil
	case processingfile.FieldExtFileRequest:
		m.ResetExtFileRequest()
		return nil
	case processingfile.FieldFileURL:
		m.ResetFileURL()
		return nil
	case processingfile.FieldResultFileURL:
		m.ResetResultFileURL()
		return nil
	case processingfile.FieldStatus:
		m.ResetStatus()
		return nil
	case processingfile.FieldFileParameters:
		m.ResetFileParameters()
		return nil
	case processingfile.FieldSellerID:
		m.ResetSellerID()
		return nil
	case processingfile.FieldTotalMapping:
		m.ResetTotalMapping()
		return nil
	case processingfile.FieldNeedGroupRow:
		m.ResetNeedGroupRow()
		return nil
	case processingfile.FieldStatsTotalRow:
		m.ResetStatsTotalRow()
		return nil
	case processingfile.FieldStatsTotalProcessed:
		m.ResetStatsTotalProcessed()
		return nil
	case processingfile.FieldStatsTotalSuccess:
		m.ResetStatsTotalSuccess()
		return nil
	case processingfile.FieldErrorDisplay:
		m.ResetErrorDisplay()
		return nil
	case processingfile.FieldTenantID:
		m.ResetTenantID()
		return nil
	case processingfile.FieldMerchantID:
		m.ResetMerchantID()
		return nil
	case processingfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processingfile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case processingfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessingFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessingFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessingFileMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessingFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessingFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessingFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessingFileMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessingFileMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessingFileMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFile edge %s", name)
}

// ProcessingFileRowMutation represents an operation that mutates the ProcessingFileRow nodes in the graph.
type ProcessingFileRowMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	file_id                 *int64
	addfile_id              *int64
	row_index               *int32
	addrow_index            *int32
	row_data_raw            *string
	task_index              *int32
	addtask_index           *int32
	task_mapping            *string
	task_depends_on         *string
	group_by_value          *string
	task_request_curl       *string
	task_request_raw        *string
	task_response_raw       *string
	status                  *int16
	addstatus               *int16
	error_display           *string
	executed_time           *int64
	addexecuted_time        *int64
	result_async            *string
	start_at                *time.Time
	receive_response_at     *time.Time
	receive_result_async_at *time.Time
	created_at              *time.Time
	updated_at              *time.Time
	clearedFields           map[string]struct{}
	done                    bool
	oldValue                func(context.Context) (*ProcessingFileRow, error)
	predicates              []predicate.ProcessingFileRow
}

var _ ent.Mutation = (*ProcessingFileRowMutation)(nil)

// processingfilerowOption allows management of the mutation configuration using functional options.
type processingfilerowOption func(*ProcessingFileRowMutation)

// newProcessingFileRowMutation creates new mutation for the ProcessingFileRow entity.
func newProcessingFileRowMutation(c config, op Op, opts ...processingfilerowOption) *ProcessingFileRowMutation {
	m := &ProcessingFileRowMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessingFileRow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessingFileRowID sets the ID field of the mutation.
func withProcessingFileRowID(id int) processingfilerowOption {
	return func(m *ProcessingFileRowMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessingFileRow
		)
		m.oldValue = func(ctx context.Context) (*ProcessingFileRow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessingFileRow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessingFileRow sets the old ProcessingFileRow of the mutation.
func withProcessingFileRow(node *ProcessingFileRow) processingfilerowOption {
	return func(m *ProcessingFileRowMutation) {
		m.oldValue = func(context.Context) (*ProcessingFileRow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessingFileRowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessingFileRowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessingFileRowMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessingFileRowMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessingFileRow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileID sets the "file_id" field.
func (m *ProcessingFileRowMutation) SetFileID(i int64) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ProcessingFileRowMutation) FileID() (r int64, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldFileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *ProcessingFileRowMutation) AddFileID(i int64) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *ProcessingFileRowMutation) AddedFileID() (r int64, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ProcessingFileRowMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetRowIndex sets the "row_index" field.
func (m *ProcessingFileRowMutation) SetRowIndex(i int32) {
	m.row_index = &i
	m.addrow_index = nil
}

// RowIndex returns the value of the "row_index" field in the mutation.
func (m *ProcessingFileRowMutation) RowIndex() (r int32, exists bool) {
	v := m.row_index
	if v == nil {
		return
	}
	return *v, true
}

// OldRowIndex returns the old "row_index" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldRowIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRowIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRowIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRowIndex: %w", err)
	}
	return oldValue.RowIndex, nil
}

// AddRowIndex adds i to the "row_index" field.
func (m *ProcessingFileRowMutation) AddRowIndex(i int32) {
	if m.addrow_index != nil {
		*m.addrow_index += i
	} else {
		m.addrow_index = &i
	}
}

// AddedRowIndex returns the value that was added to the "row_index" field in this mutation.
func (m *ProcessingFileRowMutation) AddedRowIndex() (r int32, exists bool) {
	v := m.addrow_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetRowIndex resets all changes to the "row_index" field.
func (m *ProcessingFileRowMutation) ResetRowIndex() {
	m.row_index = nil
	m.addrow_index = nil
}

// SetRowDataRaw sets the "row_data_raw" field.
func (m *ProcessingFileRowMutation) SetRowDataRaw(s string) {
	m.row_data_raw = &s
}

// RowDataRaw returns the value of the "row_data_raw" field in the mutation.
func (m *ProcessingFileRowMutation) RowDataRaw() (r string, exists bool) {
	v := m.row_data_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldRowDataRaw returns the old "row_data_raw" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldRowDataRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRowDataRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRowDataRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRowDataRaw: %w", err)
	}
	return oldValue.RowDataRaw, nil
}

// ResetRowDataRaw resets all changes to the "row_data_raw" field.
func (m *ProcessingFileRowMutation) ResetRowDataRaw() {
	m.row_data_raw = nil
}

// SetTaskIndex sets the "task_index" field.
func (m *ProcessingFileRowMutation) SetTaskIndex(i int32) {
	m.task_index = &i
	m.addtask_index = nil
}

// TaskIndex returns the value of the "task_index" field in the mutation.
func (m *ProcessingFileRowMutation) TaskIndex() (r int32, exists bool) {
	v := m.task_index
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskIndex returns the old "task_index" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskIndex: %w", err)
	}
	return oldValue.TaskIndex, nil
}

// AddTaskIndex adds i to the "task_index" field.
func (m *ProcessingFileRowMutation) AddTaskIndex(i int32) {
	if m.addtask_index != nil {
		*m.addtask_index += i
	} else {
		m.addtask_index = &i
	}
}

// AddedTaskIndex returns the value that was added to the "task_index" field in this mutation.
func (m *ProcessingFileRowMutation) AddedTaskIndex() (r int32, exists bool) {
	v := m.addtask_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskIndex resets all changes to the "task_index" field.
func (m *ProcessingFileRowMutation) ResetTaskIndex() {
	m.task_index = nil
	m.addtask_index = nil
}

// SetTaskMapping sets the "task_mapping" field.
func (m *ProcessingFileRowMutation) SetTaskMapping(s string) {
	m.task_mapping = &s
}

// TaskMapping returns the value of the "task_mapping" field in the mutation.
func (m *ProcessingFileRowMutation) TaskMapping() (r string, exists bool) {
	v := m.task_mapping
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskMapping returns the old "task_mapping" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskMapping(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskMapping is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskMapping requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskMapping: %w", err)
	}
	return oldValue.TaskMapping, nil
}

// ResetTaskMapping resets all changes to the "task_mapping" field.
func (m *ProcessingFileRowMutation) ResetTaskMapping() {
	m.task_mapping = nil
}

// SetTaskDependsOn sets the "task_depends_on" field.
func (m *ProcessingFileRowMutation) SetTaskDependsOn(s string) {
	m.task_depends_on = &s
}

// TaskDependsOn returns the value of the "task_depends_on" field in the mutation.
func (m *ProcessingFileRowMutation) TaskDependsOn() (r string, exists bool) {
	v := m.task_depends_on
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskDependsOn returns the old "task_depends_on" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskDependsOn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskDependsOn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskDependsOn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskDependsOn: %w", err)
	}
	return oldValue.TaskDependsOn, nil
}

// ResetTaskDependsOn resets all changes to the "task_depends_on" field.
func (m *ProcessingFileRowMutation) ResetTaskDependsOn() {
	m.task_depends_on = nil
}

// SetGroupByValue sets the "group_by_value" field.
func (m *ProcessingFileRowMutation) SetGroupByValue(s string) {
	m.group_by_value = &s
}

// GroupByValue returns the value of the "group_by_value" field in the mutation.
func (m *ProcessingFileRowMutation) GroupByValue() (r string, exists bool) {
	v := m.group_by_value
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupByValue returns the old "group_by_value" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldGroupByValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupByValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupByValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupByValue: %w", err)
	}
	return oldValue.GroupByValue, nil
}

// ResetGroupByValue resets all changes to the "group_by_value" field.
func (m *ProcessingFileRowMutation) ResetGroupByValue() {
	m.group_by_value = nil
}

// SetTaskRequestCurl sets the "task_request_curl" field.
func (m *ProcessingFileRowMutation) SetTaskRequestCurl(s string) {
	m.task_request_curl = &s
}

// TaskRequestCurl returns the value of the "task_request_curl" field in the mutation.
func (m *ProcessingFileRowMutation) TaskRequestCurl() (r string, exists bool) {
	v := m.task_request_curl
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskRequestCurl returns the old "task_request_curl" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskRequestCurl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskRequestCurl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskRequestCurl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskRequestCurl: %w", err)
	}
	return oldValue.TaskRequestCurl, nil
}

// ResetTaskRequestCurl resets all changes to the "task_request_curl" field.
func (m *ProcessingFileRowMutation) ResetTaskRequestCurl() {
	m.task_request_curl = nil
}

// SetTaskRequestRaw sets the "task_request_raw" field.
func (m *ProcessingFileRowMutation) SetTaskRequestRaw(s string) {
	m.task_request_raw = &s
}

// TaskRequestRaw returns the value of the "task_request_raw" field in the mutation.
func (m *ProcessingFileRowMutation) TaskRequestRaw() (r string, exists bool) {
	v := m.task_request_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskRequestRaw returns the old "task_request_raw" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskRequestRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskRequestRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskRequestRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskRequestRaw: %w", err)
	}
	return oldValue.TaskRequestRaw, nil
}

// ResetTaskRequestRaw resets all changes to the "task_request_raw" field.
func (m *ProcessingFileRowMutation) ResetTaskRequestRaw() {
	m.task_request_raw = nil
}

// SetTaskResponseRaw sets the "task_response_raw" field.
func (m *ProcessingFileRowMutation) SetTaskResponseRaw(s string) {
	m.task_response_raw = &s
}

// TaskResponseRaw returns the value of the "task_response_raw" field in the mutation.
func (m *ProcessingFileRowMutation) TaskResponseRaw() (r string, exists bool) {
	v := m.task_response_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskResponseRaw returns the old "task_response_raw" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldTaskResponseRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskResponseRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskResponseRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskResponseRaw: %w", err)
	}
	return oldValue.TaskResponseRaw, nil
}

// ResetTaskResponseRaw resets all changes to the "task_response_raw" field.
func (m *ProcessingFileRowMutation) ResetTaskResponseRaw() {
	m.task_response_raw = nil
}

// SetStatus sets the "status" field.
func (m *ProcessingFileRowMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessingFileRowMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProcessingFileRowMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProcessingFileRowMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessingFileRowMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetErrorDisplay sets the "error_display" field.
func (m *ProcessingFileRowMutation) SetErrorDisplay(s string) {
	m.error_display = &s
}

// ErrorDisplay returns the value of the "error_display" field in the mutation.
func (m *ProcessingFileRowMutation) ErrorDisplay() (r string, exists bool) {
	v := m.error_display
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDisplay returns the old "error_display" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldErrorDisplay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDisplay: %w", err)
	}
	return oldValue.ErrorDisplay, nil
}

// ResetErrorDisplay resets all changes to the "error_display" field.
func (m *ProcessingFileRowMutation) ResetErrorDisplay() {
	m.error_display = nil
}

// SetExecutedTime sets the "executed_time" field.
func (m *ProcessingFileRowMutation) SetExecutedTime(i int64) {
	m.executed_time = &i
	m.addexecuted_time = nil
}

// ExecutedTime returns the value of the "executed_time" field in the mutation.
func (m *ProcessingFileRowMutation) ExecutedTime() (r int64, exists bool) {
	v := m.executed_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutedTime returns the old "executed_time" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldExecutedTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutedTime: %w", err)
	}
	return oldValue.ExecutedTime, nil
}

// AddExecutedTime adds i to the "executed_time" field.
func (m *ProcessingFileRowMutation) AddExecutedTime(i int64) {
	if m.addexecuted_time != nil {
		*m.addexecuted_time += i
	} else {
		m.addexecuted_time = &i
	}
}

// AddedExecutedTime returns the value that was added to the "executed_time" field in this mutation.
func (m *ProcessingFileRowMutation) AddedExecutedTime() (r int64, exists bool) {
	v := m.addexecuted_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutedTime resets all changes to the "executed_time" field.
func (m *ProcessingFileRowMutation) ResetExecutedTime() {
	m.executed_time = nil
	m.addexecuted_time = nil
}

// SetResultAsync sets the "result_async" field.
func (m *ProcessingFileRowMutation) SetResultAsync(s string) {
	m.result_async = &s
}

// ResultAsync returns the value of the "result_async" field in the mutation.
func (m *ProcessingFileRowMutation) ResultAsync() (r string, exists bool) {
	v := m.result_async
	if v == nil {
		return
	}
	return *v, true
}

// OldResultAsync returns the old "result_async" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldResultAsync(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResultAsync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResultAsync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResultAsync: %w", err)
	}
	return oldValue.ResultAsync, nil
}

// ClearResultAsync clears the value of the "result_async" field.
func (m *ProcessingFileRowMutation) ClearResultAsync() {
	m.result_async = nil
	m.clearedFields[processingfilerow.FieldResultAsync] = struct{}{}
}

// ResultAsyncCleared returns if the "result_async" field was cleared in this mutation.
func (m *ProcessingFileRowMutation) ResultAsyncCleared() bool {
	_, ok := m.clearedFields[processingfilerow.FieldResultAsync]
	return ok
}

// ResetResultAsync resets all changes to the "result_async" field.
func (m *ProcessingFileRowMutation) ResetResultAsync() {
	m.result_async = nil
	delete(m.clearedFields, processingfilerow.FieldResultAsync)
}

// SetStartAt sets the "start_at" field.
func (m *ProcessingFileRowMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *ProcessingFileRowMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldStartAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ClearStartAt clears the value of the "start_at" field.
func (m *ProcessingFileRowMutation) ClearStartAt() {
	m.start_at = nil
	m.clearedFields[processingfilerow.FieldStartAt] = struct{}{}
}

// StartAtCleared returns if the "start_at" field was cleared in this mutation.
func (m *ProcessingFileRowMutation) StartAtCleared() bool {
	_, ok := m.clearedFields[processingfilerow.FieldStartAt]
	return ok
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *ProcessingFileRowMutation) ResetStartAt() {
	m.start_at = nil
	delete(m.clearedFields, processingfilerow.FieldStartAt)
}

// SetReceiveResponseAt sets the "receive_response_at" field.
func (m *ProcessingFileRowMutation) SetReceiveResponseAt(t time.Time) {
	m.receive_response_at = &t
}

// ReceiveResponseAt returns the value of the "receive_response_at" field in the mutation.
func (m *ProcessingFileRowMutation) ReceiveResponseAt() (r time.Time, exists bool) {
	v := m.receive_response_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveResponseAt returns the old "receive_response_at" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldReceiveResponseAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveResponseAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveResponseAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveResponseAt: %w", err)
	}
	return oldValue.ReceiveResponseAt, nil
}

// ClearReceiveResponseAt clears the value of the "receive_response_at" field.
func (m *ProcessingFileRowMutation) ClearReceiveResponseAt() {
	m.receive_response_at = nil
	m.clearedFields[processingfilerow.FieldReceiveResponseAt] = struct{}{}
}

// ReceiveResponseAtCleared returns if the "receive_response_at" field was cleared in this mutation.
func (m *ProcessingFileRowMutation) ReceiveResponseAtCleared() bool {
	_, ok := m.clearedFields[processingfilerow.FieldReceiveResponseAt]
	return ok
}

// ResetReceiveResponseAt resets all changes to the "receive_response_at" field.
func (m *ProcessingFileRowMutation) ResetReceiveResponseAt() {
	m.receive_response_at = nil
	delete(m.clearedFields, processingfilerow.FieldReceiveResponseAt)
}

// SetReceiveResultAsyncAt sets the "receive_result_async_at" field.
func (m *ProcessingFileRowMutation) SetReceiveResultAsyncAt(t time.Time) {
	m.receive_result_async_at = &t
}

// ReceiveResultAsyncAt returns the value of the "receive_result_async_at" field in the mutation.
func (m *ProcessingFileRowMutation) ReceiveResultAsyncAt() (r time.Time, exists bool) {
	v := m.receive_result_async_at
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiveResultAsyncAt returns the old "receive_result_async_at" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldReceiveResultAsyncAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiveResultAsyncAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiveResultAsyncAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiveResultAsyncAt: %w", err)
	}
	return oldValue.ReceiveResultAsyncAt, nil
}

// ClearReceiveResultAsyncAt clears the value of the "receive_result_async_at" field.
func (m *ProcessingFileRowMutation) ClearReceiveResultAsyncAt() {
	m.receive_result_async_at = nil
	m.clearedFields[processingfilerow.FieldReceiveResultAsyncAt] = struct{}{}
}

// ReceiveResultAsyncAtCleared returns if the "receive_result_async_at" field was cleared in this mutation.
func (m *ProcessingFileRowMutation) ReceiveResultAsyncAtCleared() bool {
	_, ok := m.clearedFields[processingfilerow.FieldReceiveResultAsyncAt]
	return ok
}

// ResetReceiveResultAsyncAt resets all changes to the "receive_result_async_at" field.
func (m *ProcessingFileRowMutation) ResetReceiveResultAsyncAt() {
	m.receive_result_async_at = nil
	delete(m.clearedFields, processingfilerow.FieldReceiveResultAsyncAt)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessingFileRowMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessingFileRowMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessingFileRowMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessingFileRowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessingFileRowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessingFileRow entity.
// If the ProcessingFileRow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessingFileRowMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessingFileRowMutation builder.
func (m *ProcessingFileRowMutation) Where(ps ...predicate.ProcessingFileRow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcessingFileRowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcessingFileRow).
func (m *ProcessingFileRowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessingFileRowMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.file_id != nil {
		fields = append(fields, processingfilerow.FieldFileID)
	}
	if m.row_index != nil {
		fields = append(fields, processingfilerow.FieldRowIndex)
	}
	if m.row_data_raw != nil {
		fields = append(fields, processingfilerow.FieldRowDataRaw)
	}
	if m.task_index != nil {
		fields = append(fields, processingfilerow.FieldTaskIndex)
	}
	if m.task_mapping != nil {
		fields = append(fields, processingfilerow.FieldTaskMapping)
	}
	if m.task_depends_on != nil {
		fields = append(fields, processingfilerow.FieldTaskDependsOn)
	}
	if m.group_by_value != nil {
		fields = append(fields, processingfilerow.FieldGroupByValue)
	}
	if m.task_request_curl != nil {
		fields = append(fields, processingfilerow.FieldTaskRequestCurl)
	}
	if m.task_request_raw != nil {
		fields = append(fields, processingfilerow.FieldTaskRequestRaw)
	}
	if m.task_response_raw != nil {
		fields = append(fields, processingfilerow.FieldTaskResponseRaw)
	}
	if m.status != nil {
		fields = append(fields, processingfilerow.FieldStatus)
	}
	if m.error_display != nil {
		fields = append(fields, processingfilerow.FieldErrorDisplay)
	}
	if m.executed_time != nil {
		fields = append(fields, processingfilerow.FieldExecutedTime)
	}
	if m.result_async != nil {
		fields = append(fields, processingfilerow.FieldResultAsync)
	}
	if m.start_at != nil {
		fields = append(fields, processingfilerow.FieldStartAt)
	}
	if m.receive_response_at != nil {
		fields = append(fields, processingfilerow.FieldReceiveResponseAt)
	}
	if m.receive_result_async_at != nil {
		fields = append(fields, processingfilerow.FieldReceiveResultAsyncAt)
	}
	if m.created_at != nil {
		fields = append(fields, processingfilerow.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processingfilerow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessingFileRowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processingfilerow.FieldFileID:
		return m.FileID()
	case processingfilerow.FieldRowIndex:
		return m.RowIndex()
	case processingfilerow.FieldRowDataRaw:
		return m.RowDataRaw()
	case processingfilerow.FieldTaskIndex:
		return m.TaskIndex()
	case processingfilerow.FieldTaskMapping:
		return m.TaskMapping()
	case processingfilerow.FieldTaskDependsOn:
		return m.TaskDependsOn()
	case processingfilerow.FieldGroupByValue:
		return m.GroupByValue()
	case processingfilerow.FieldTaskRequestCurl:
		return m.TaskRequestCurl()
	case processingfilerow.FieldTaskRequestRaw:
		return m.TaskRequestRaw()
	case processingfilerow.FieldTaskResponseRaw:
		return m.TaskResponseRaw()
	case processingfilerow.FieldStatus:
		return m.Status()
	case processingfilerow.FieldErrorDisplay:
		return m.ErrorDisplay()
	case processingfilerow.FieldExecutedTime:
		return m.ExecutedTime()
	case processingfilerow.FieldResultAsync:
		return m.ResultAsync()
	case processingfilerow.FieldStartAt:
		return m.StartAt()
	case processingfilerow.FieldReceiveResponseAt:
		return m.ReceiveResponseAt()
	case processingfilerow.FieldReceiveResultAsyncAt:
		return m.ReceiveResultAsyncAt()
	case processingfilerow.FieldCreatedAt:
		return m.CreatedAt()
	case processingfilerow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessingFileRowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processingfilerow.FieldFileID:
		return m.OldFileID(ctx)
	case processingfilerow.FieldRowIndex:
		return m.OldRowIndex(ctx)
	case processingfilerow.FieldRowDataRaw:
		return m.OldRowDataRaw(ctx)
	case processingfilerow.FieldTaskIndex:
		return m.OldTaskIndex(ctx)
	case processingfilerow.FieldTaskMapping:
		return m.OldTaskMapping(ctx)
	case processingfilerow.FieldTaskDependsOn:
		return m.OldTaskDependsOn(ctx)
	case processingfilerow.FieldGroupByValue:
		return m.OldGroupByValue(ctx)
	case processingfilerow.FieldTaskRequestCurl:
		return m.OldTaskRequestCurl(ctx)
	case processingfilerow.FieldTaskRequestRaw:
		return m.OldTaskRequestRaw(ctx)
	case processingfilerow.FieldTaskResponseRaw:
		return m.OldTaskResponseRaw(ctx)
	case processingfilerow.FieldStatus:
		return m.OldStatus(ctx)
	case processingfilerow.FieldErrorDisplay:
		return m.OldErrorDisplay(ctx)
	case processingfilerow.FieldExecutedTime:
		return m.OldExecutedTime(ctx)
	case processingfilerow.FieldResultAsync:
		return m.OldResultAsync(ctx)
	case processingfilerow.FieldStartAt:
		return m.OldStartAt(ctx)
	case processingfilerow.FieldReceiveResponseAt:
		return m.OldReceiveResponseAt(ctx)
	case processingfilerow.FieldReceiveResultAsyncAt:
		return m.OldReceiveResultAsyncAt(ctx)
	case processingfilerow.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processingfilerow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessingFileRow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileRowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processingfilerow.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case processingfilerow.FieldRowIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRowIndex(v)
		return nil
	case processingfilerow.FieldRowDataRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRowDataRaw(v)
		return nil
	case processingfilerow.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskIndex(v)
		return nil
	case processingfilerow.FieldTaskMapping:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskMapping(v)
		return nil
	case processingfilerow.FieldTaskDependsOn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskDependsOn(v)
		return nil
	case processingfilerow.FieldGroupByValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupByValue(v)
		return nil
	case processingfilerow.FieldTaskRequestCurl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskRequestCurl(v)
		return nil
	case processingfilerow.FieldTaskRequestRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskRequestRaw(v)
		return nil
	case processingfilerow.FieldTaskResponseRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskResponseRaw(v)
		return nil
	case processingfilerow.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processingfilerow.FieldErrorDisplay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDisplay(v)
		return nil
	case processingfilerow.FieldExecutedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutedTime(v)
		return nil
	case processingfilerow.FieldResultAsync:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResultAsync(v)
		return nil
	case processingfilerow.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case processingfilerow.FieldReceiveResponseAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveResponseAt(v)
		return nil
	case processingfilerow.FieldReceiveResultAsyncAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiveResultAsyncAt(v)
		return nil
	case processingfilerow.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processingfilerow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessingFileRowMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, processingfilerow.FieldFileID)
	}
	if m.addrow_index != nil {
		fields = append(fields, processingfilerow.FieldRowIndex)
	}
	if m.addtask_index != nil {
		fields = append(fields, processingfilerow.FieldTaskIndex)
	}
	if m.addstatus != nil {
		fields = append(fields, processingfilerow.FieldStatus)
	}
	if m.addexecuted_time != nil {
		fields = append(fields, processingfilerow.FieldExecutedTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessingFileRowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processingfilerow.FieldFileID:
		return m.AddedFileID()
	case processingfilerow.FieldRowIndex:
		return m.AddedRowIndex()
	case processingfilerow.FieldTaskIndex:
		return m.AddedTaskIndex()
	case processingfilerow.FieldStatus:
		return m.AddedStatus()
	case processingfilerow.FieldExecutedTime:
		return m.AddedExecutedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileRowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processingfilerow.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case processingfilerow.FieldRowIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRowIndex(v)
		return nil
	case processingfilerow.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskIndex(v)
		return nil
	case processingfilerow.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case processingfilerow.FieldExecutedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessingFileRowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(processingfilerow.FieldResultAsync) {
		fields = append(fields, processingfilerow.FieldResultAsync)
	}
	if m.FieldCleared(processingfilerow.FieldStartAt) {
		fields = append(fields, processingfilerow.FieldStartAt)
	}
	if m.FieldCleared(processingfilerow.FieldReceiveResponseAt) {
		fields = append(fields, processingfilerow.FieldReceiveResponseAt)
	}
	if m.FieldCleared(processingfilerow.FieldReceiveResultAsyncAt) {
		fields = append(fields, processingfilerow.FieldReceiveResultAsyncAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessingFileRowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessingFileRowMutation) ClearField(name string) error {
	switch name {
	case processingfilerow.FieldResultAsync:
		m.ClearResultAsync()
		return nil
	case processingfilerow.FieldStartAt:
		m.ClearStartAt()
		return nil
	case processingfilerow.FieldReceiveResponseAt:
		m.ClearReceiveResponseAt()
		return nil
	case processingfilerow.FieldReceiveResultAsyncAt:
		m.ClearReceiveResultAsyncAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessingFileRowMutation) ResetField(name string) error {
	switch name {
	case processingfilerow.FieldFileID:
		m.ResetFileID()
		return nil
	case processingfilerow.FieldRowIndex:
		m.ResetRowIndex()
		return nil
	case processingfilerow.FieldRowDataRaw:
		m.ResetRowDataRaw()
		return nil
	case processingfilerow.FieldTaskIndex:
		m.ResetTaskIndex()
		return nil
	case processingfilerow.FieldTaskMapping:
		m.ResetTaskMapping()
		return nil
	case processingfilerow.FieldTaskDependsOn:
		m.ResetTaskDependsOn()
		return nil
	case processingfilerow.FieldGroupByValue:
		m.ResetGroupByValue()
		return nil
	case processingfilerow.FieldTaskRequestCurl:
		m.ResetTaskRequestCurl()
		return nil
	case processingfilerow.FieldTaskRequestRaw:
		m.ResetTaskRequestRaw()
		return nil
	case processingfilerow.FieldTaskResponseRaw:
		m.ResetTaskResponseRaw()
		return nil
	case processingfilerow.FieldStatus:
		m.ResetStatus()
		return nil
	case processingfilerow.FieldErrorDisplay:
		m.ResetErrorDisplay()
		return nil
	case processingfilerow.FieldExecutedTime:
		m.ResetExecutedTime()
		return nil
	case processingfilerow.FieldResultAsync:
		m.ResetResultAsync()
		return nil
	case processingfilerow.FieldStartAt:
		m.ResetStartAt()
		return nil
	case processingfilerow.FieldReceiveResponseAt:
		m.ResetReceiveResponseAt()
		return nil
	case processingfilerow.FieldReceiveResultAsyncAt:
		m.ResetReceiveResultAsyncAt()
		return nil
	case processingfilerow.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processingfilerow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessingFileRowMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessingFileRowMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessingFileRowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessingFileRowMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessingFileRowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessingFileRowMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessingFileRowMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFileRow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessingFileRowMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFileRow edge %s", name)
}

// ProcessingFileRowGroupMutation represents an operation that mutates the ProcessingFileRowGroup nodes in the graph.
type ProcessingFileRowGroupMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	file_id            *int64
	addfile_id         *int64
	task_index         *int32
	addtask_index      *int32
	group_by_value     *string
	total_rows         *int32
	addtotal_rows      *int32
	row_index_list     *string
	group_request_curl *string
	group_response_raw *string
	status             *int16
	addstatus          *int16
	error_display      *string
	executed_time      *int64
	addexecuted_time   *int64
	created_at         *time.Time
	updated_at         *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*ProcessingFileRowGroup, error)
	predicates         []predicate.ProcessingFileRowGroup
}

var _ ent.Mutation = (*ProcessingFileRowGroupMutation)(nil)

// processingfilerowgroupOption allows management of the mutation configuration using functional options.
type processingfilerowgroupOption func(*ProcessingFileRowGroupMutation)

// newProcessingFileRowGroupMutation creates new mutation for the ProcessingFileRowGroup entity.
func newProcessingFileRowGroupMutation(c config, op Op, opts ...processingfilerowgroupOption) *ProcessingFileRowGroupMutation {
	m := &ProcessingFileRowGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeProcessingFileRowGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProcessingFileRowGroupID sets the ID field of the mutation.
func withProcessingFileRowGroupID(id int) processingfilerowgroupOption {
	return func(m *ProcessingFileRowGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *ProcessingFileRowGroup
		)
		m.oldValue = func(ctx context.Context) (*ProcessingFileRowGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProcessingFileRowGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProcessingFileRowGroup sets the old ProcessingFileRowGroup of the mutation.
func withProcessingFileRowGroup(node *ProcessingFileRowGroup) processingfilerowgroupOption {
	return func(m *ProcessingFileRowGroupMutation) {
		m.oldValue = func(context.Context) (*ProcessingFileRowGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProcessingFileRowGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProcessingFileRowGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProcessingFileRowGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProcessingFileRowGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProcessingFileRowGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFileID sets the "file_id" field.
func (m *ProcessingFileRowGroupMutation) SetFileID(i int64) {
	m.file_id = &i
	m.addfile_id = nil
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *ProcessingFileRowGroupMutation) FileID() (r int64, exists bool) {
	v := m.file_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldFileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// AddFileID adds i to the "file_id" field.
func (m *ProcessingFileRowGroupMutation) AddFileID(i int64) {
	if m.addfile_id != nil {
		*m.addfile_id += i
	} else {
		m.addfile_id = &i
	}
}

// AddedFileID returns the value that was added to the "file_id" field in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedFileID() (r int64, exists bool) {
	v := m.addfile_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetFileID resets all changes to the "file_id" field.
func (m *ProcessingFileRowGroupMutation) ResetFileID() {
	m.file_id = nil
	m.addfile_id = nil
}

// SetTaskIndex sets the "task_index" field.
func (m *ProcessingFileRowGroupMutation) SetTaskIndex(i int32) {
	m.task_index = &i
	m.addtask_index = nil
}

// TaskIndex returns the value of the "task_index" field in the mutation.
func (m *ProcessingFileRowGroupMutation) TaskIndex() (r int32, exists bool) {
	v := m.task_index
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskIndex returns the old "task_index" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldTaskIndex(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTaskIndex is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTaskIndex requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskIndex: %w", err)
	}
	return oldValue.TaskIndex, nil
}

// AddTaskIndex adds i to the "task_index" field.
func (m *ProcessingFileRowGroupMutation) AddTaskIndex(i int32) {
	if m.addtask_index != nil {
		*m.addtask_index += i
	} else {
		m.addtask_index = &i
	}
}

// AddedTaskIndex returns the value that was added to the "task_index" field in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedTaskIndex() (r int32, exists bool) {
	v := m.addtask_index
	if v == nil {
		return
	}
	return *v, true
}

// ResetTaskIndex resets all changes to the "task_index" field.
func (m *ProcessingFileRowGroupMutation) ResetTaskIndex() {
	m.task_index = nil
	m.addtask_index = nil
}

// SetGroupByValue sets the "group_by_value" field.
func (m *ProcessingFileRowGroupMutation) SetGroupByValue(s string) {
	m.group_by_value = &s
}

// GroupByValue returns the value of the "group_by_value" field in the mutation.
func (m *ProcessingFileRowGroupMutation) GroupByValue() (r string, exists bool) {
	v := m.group_by_value
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupByValue returns the old "group_by_value" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldGroupByValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupByValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupByValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupByValue: %w", err)
	}
	return oldValue.GroupByValue, nil
}

// ResetGroupByValue resets all changes to the "group_by_value" field.
func (m *ProcessingFileRowGroupMutation) ResetGroupByValue() {
	m.group_by_value = nil
}

// SetTotalRows sets the "total_rows" field.
func (m *ProcessingFileRowGroupMutation) SetTotalRows(i int32) {
	m.total_rows = &i
	m.addtotal_rows = nil
}

// TotalRows returns the value of the "total_rows" field in the mutation.
func (m *ProcessingFileRowGroupMutation) TotalRows() (r int32, exists bool) {
	v := m.total_rows
	if v == nil {
		return
	}
	return *v, true
}

// OldTotalRows returns the old "total_rows" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldTotalRows(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTotalRows is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTotalRows requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTotalRows: %w", err)
	}
	return oldValue.TotalRows, nil
}

// AddTotalRows adds i to the "total_rows" field.
func (m *ProcessingFileRowGroupMutation) AddTotalRows(i int32) {
	if m.addtotal_rows != nil {
		*m.addtotal_rows += i
	} else {
		m.addtotal_rows = &i
	}
}

// AddedTotalRows returns the value that was added to the "total_rows" field in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedTotalRows() (r int32, exists bool) {
	v := m.addtotal_rows
	if v == nil {
		return
	}
	return *v, true
}

// ResetTotalRows resets all changes to the "total_rows" field.
func (m *ProcessingFileRowGroupMutation) ResetTotalRows() {
	m.total_rows = nil
	m.addtotal_rows = nil
}

// SetRowIndexList sets the "row_index_list" field.
func (m *ProcessingFileRowGroupMutation) SetRowIndexList(s string) {
	m.row_index_list = &s
}

// RowIndexList returns the value of the "row_index_list" field in the mutation.
func (m *ProcessingFileRowGroupMutation) RowIndexList() (r string, exists bool) {
	v := m.row_index_list
	if v == nil {
		return
	}
	return *v, true
}

// OldRowIndexList returns the old "row_index_list" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldRowIndexList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRowIndexList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRowIndexList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRowIndexList: %w", err)
	}
	return oldValue.RowIndexList, nil
}

// ResetRowIndexList resets all changes to the "row_index_list" field.
func (m *ProcessingFileRowGroupMutation) ResetRowIndexList() {
	m.row_index_list = nil
}

// SetGroupRequestCurl sets the "group_request_curl" field.
func (m *ProcessingFileRowGroupMutation) SetGroupRequestCurl(s string) {
	m.group_request_curl = &s
}

// GroupRequestCurl returns the value of the "group_request_curl" field in the mutation.
func (m *ProcessingFileRowGroupMutation) GroupRequestCurl() (r string, exists bool) {
	v := m.group_request_curl
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupRequestCurl returns the old "group_request_curl" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldGroupRequestCurl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupRequestCurl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupRequestCurl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupRequestCurl: %w", err)
	}
	return oldValue.GroupRequestCurl, nil
}

// ResetGroupRequestCurl resets all changes to the "group_request_curl" field.
func (m *ProcessingFileRowGroupMutation) ResetGroupRequestCurl() {
	m.group_request_curl = nil
}

// SetGroupResponseRaw sets the "group_response_raw" field.
func (m *ProcessingFileRowGroupMutation) SetGroupResponseRaw(s string) {
	m.group_response_raw = &s
}

// GroupResponseRaw returns the value of the "group_response_raw" field in the mutation.
func (m *ProcessingFileRowGroupMutation) GroupResponseRaw() (r string, exists bool) {
	v := m.group_response_raw
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupResponseRaw returns the old "group_response_raw" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldGroupResponseRaw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupResponseRaw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupResponseRaw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupResponseRaw: %w", err)
	}
	return oldValue.GroupResponseRaw, nil
}

// ResetGroupResponseRaw resets all changes to the "group_response_raw" field.
func (m *ProcessingFileRowGroupMutation) ResetGroupResponseRaw() {
	m.group_response_raw = nil
}

// SetStatus sets the "status" field.
func (m *ProcessingFileRowGroupMutation) SetStatus(i int16) {
	m.status = &i
	m.addstatus = nil
}

// Status returns the value of the "status" field in the mutation.
func (m *ProcessingFileRowGroupMutation) Status() (r int16, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldStatus(ctx context.Context) (v int16, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// AddStatus adds i to the "status" field.
func (m *ProcessingFileRowGroupMutation) AddStatus(i int16) {
	if m.addstatus != nil {
		*m.addstatus += i
	} else {
		m.addstatus = &i
	}
}

// AddedStatus returns the value that was added to the "status" field in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedStatus() (r int16, exists bool) {
	v := m.addstatus
	if v == nil {
		return
	}
	return *v, true
}

// ResetStatus resets all changes to the "status" field.
func (m *ProcessingFileRowGroupMutation) ResetStatus() {
	m.status = nil
	m.addstatus = nil
}

// SetErrorDisplay sets the "error_display" field.
func (m *ProcessingFileRowGroupMutation) SetErrorDisplay(s string) {
	m.error_display = &s
}

// ErrorDisplay returns the value of the "error_display" field in the mutation.
func (m *ProcessingFileRowGroupMutation) ErrorDisplay() (r string, exists bool) {
	v := m.error_display
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorDisplay returns the old "error_display" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldErrorDisplay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorDisplay: %w", err)
	}
	return oldValue.ErrorDisplay, nil
}

// ResetErrorDisplay resets all changes to the "error_display" field.
func (m *ProcessingFileRowGroupMutation) ResetErrorDisplay() {
	m.error_display = nil
}

// SetExecutedTime sets the "executed_time" field.
func (m *ProcessingFileRowGroupMutation) SetExecutedTime(i int64) {
	m.executed_time = &i
	m.addexecuted_time = nil
}

// ExecutedTime returns the value of the "executed_time" field in the mutation.
func (m *ProcessingFileRowGroupMutation) ExecutedTime() (r int64, exists bool) {
	v := m.executed_time
	if v == nil {
		return
	}
	return *v, true
}

// OldExecutedTime returns the old "executed_time" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldExecutedTime(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExecutedTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExecutedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExecutedTime: %w", err)
	}
	return oldValue.ExecutedTime, nil
}

// AddExecutedTime adds i to the "executed_time" field.
func (m *ProcessingFileRowGroupMutation) AddExecutedTime(i int64) {
	if m.addexecuted_time != nil {
		*m.addexecuted_time += i
	} else {
		m.addexecuted_time = &i
	}
}

// AddedExecutedTime returns the value that was added to the "executed_time" field in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedExecutedTime() (r int64, exists bool) {
	v := m.addexecuted_time
	if v == nil {
		return
	}
	return *v, true
}

// ResetExecutedTime resets all changes to the "executed_time" field.
func (m *ProcessingFileRowGroupMutation) ResetExecutedTime() {
	m.executed_time = nil
	m.addexecuted_time = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProcessingFileRowGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProcessingFileRowGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProcessingFileRowGroupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProcessingFileRowGroupMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProcessingFileRowGroupMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProcessingFileRowGroup entity.
// If the ProcessingFileRowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProcessingFileRowGroupMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProcessingFileRowGroupMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the ProcessingFileRowGroupMutation builder.
func (m *ProcessingFileRowGroupMutation) Where(ps ...predicate.ProcessingFileRowGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProcessingFileRowGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProcessingFileRowGroup).
func (m *ProcessingFileRowGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProcessingFileRowGroupMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.file_id != nil {
		fields = append(fields, processingfilerowgroup.FieldFileID)
	}
	if m.task_index != nil {
		fields = append(fields, processingfilerowgroup.FieldTaskIndex)
	}
	if m.group_by_value != nil {
		fields = append(fields, processingfilerowgroup.FieldGroupByValue)
	}
	if m.total_rows != nil {
		fields = append(fields, processingfilerowgroup.FieldTotalRows)
	}
	if m.row_index_list != nil {
		fields = append(fields, processingfilerowgroup.FieldRowIndexList)
	}
	if m.group_request_curl != nil {
		fields = append(fields, processingfilerowgroup.FieldGroupRequestCurl)
	}
	if m.group_response_raw != nil {
		fields = append(fields, processingfilerowgroup.FieldGroupResponseRaw)
	}
	if m.status != nil {
		fields = append(fields, processingfilerowgroup.FieldStatus)
	}
	if m.error_display != nil {
		fields = append(fields, processingfilerowgroup.FieldErrorDisplay)
	}
	if m.executed_time != nil {
		fields = append(fields, processingfilerowgroup.FieldExecutedTime)
	}
	if m.created_at != nil {
		fields = append(fields, processingfilerowgroup.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, processingfilerowgroup.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProcessingFileRowGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case processingfilerowgroup.FieldFileID:
		return m.FileID()
	case processingfilerowgroup.FieldTaskIndex:
		return m.TaskIndex()
	case processingfilerowgroup.FieldGroupByValue:
		return m.GroupByValue()
	case processingfilerowgroup.FieldTotalRows:
		return m.TotalRows()
	case processingfilerowgroup.FieldRowIndexList:
		return m.RowIndexList()
	case processingfilerowgroup.FieldGroupRequestCurl:
		return m.GroupRequestCurl()
	case processingfilerowgroup.FieldGroupResponseRaw:
		return m.GroupResponseRaw()
	case processingfilerowgroup.FieldStatus:
		return m.Status()
	case processingfilerowgroup.FieldErrorDisplay:
		return m.ErrorDisplay()
	case processingfilerowgroup.FieldExecutedTime:
		return m.ExecutedTime()
	case processingfilerowgroup.FieldCreatedAt:
		return m.CreatedAt()
	case processingfilerowgroup.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProcessingFileRowGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case processingfilerowgroup.FieldFileID:
		return m.OldFileID(ctx)
	case processingfilerowgroup.FieldTaskIndex:
		return m.OldTaskIndex(ctx)
	case processingfilerowgroup.FieldGroupByValue:
		return m.OldGroupByValue(ctx)
	case processingfilerowgroup.FieldTotalRows:
		return m.OldTotalRows(ctx)
	case processingfilerowgroup.FieldRowIndexList:
		return m.OldRowIndexList(ctx)
	case processingfilerowgroup.FieldGroupRequestCurl:
		return m.OldGroupRequestCurl(ctx)
	case processingfilerowgroup.FieldGroupResponseRaw:
		return m.OldGroupResponseRaw(ctx)
	case processingfilerowgroup.FieldStatus:
		return m.OldStatus(ctx)
	case processingfilerowgroup.FieldErrorDisplay:
		return m.OldErrorDisplay(ctx)
	case processingfilerowgroup.FieldExecutedTime:
		return m.OldExecutedTime(ctx)
	case processingfilerowgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case processingfilerowgroup.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProcessingFileRowGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileRowGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case processingfilerowgroup.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case processingfilerowgroup.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskIndex(v)
		return nil
	case processingfilerowgroup.FieldGroupByValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupByValue(v)
		return nil
	case processingfilerowgroup.FieldTotalRows:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTotalRows(v)
		return nil
	case processingfilerowgroup.FieldRowIndexList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRowIndexList(v)
		return nil
	case processingfilerowgroup.FieldGroupRequestCurl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupRequestCurl(v)
		return nil
	case processingfilerowgroup.FieldGroupResponseRaw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupResponseRaw(v)
		return nil
	case processingfilerowgroup.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case processingfilerowgroup.FieldErrorDisplay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorDisplay(v)
		return nil
	case processingfilerowgroup.FieldExecutedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExecutedTime(v)
		return nil
	case processingfilerowgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case processingfilerowgroup.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRowGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProcessingFileRowGroupMutation) AddedFields() []string {
	var fields []string
	if m.addfile_id != nil {
		fields = append(fields, processingfilerowgroup.FieldFileID)
	}
	if m.addtask_index != nil {
		fields = append(fields, processingfilerowgroup.FieldTaskIndex)
	}
	if m.addtotal_rows != nil {
		fields = append(fields, processingfilerowgroup.FieldTotalRows)
	}
	if m.addstatus != nil {
		fields = append(fields, processingfilerowgroup.FieldStatus)
	}
	if m.addexecuted_time != nil {
		fields = append(fields, processingfilerowgroup.FieldExecutedTime)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProcessingFileRowGroupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case processingfilerowgroup.FieldFileID:
		return m.AddedFileID()
	case processingfilerowgroup.FieldTaskIndex:
		return m.AddedTaskIndex()
	case processingfilerowgroup.FieldTotalRows:
		return m.AddedTotalRows()
	case processingfilerowgroup.FieldStatus:
		return m.AddedStatus()
	case processingfilerowgroup.FieldExecutedTime:
		return m.AddedExecutedTime()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProcessingFileRowGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case processingfilerowgroup.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFileID(v)
		return nil
	case processingfilerowgroup.FieldTaskIndex:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTaskIndex(v)
		return nil
	case processingfilerowgroup.FieldTotalRows:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTotalRows(v)
		return nil
	case processingfilerowgroup.FieldStatus:
		v, ok := value.(int16)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStatus(v)
		return nil
	case processingfilerowgroup.FieldExecutedTime:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExecutedTime(v)
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRowGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProcessingFileRowGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProcessingFileRowGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProcessingFileRowGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProcessingFileRowGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProcessingFileRowGroupMutation) ResetField(name string) error {
	switch name {
	case processingfilerowgroup.FieldFileID:
		m.ResetFileID()
		return nil
	case processingfilerowgroup.FieldTaskIndex:
		m.ResetTaskIndex()
		return nil
	case processingfilerowgroup.FieldGroupByValue:
		m.ResetGroupByValue()
		return nil
	case processingfilerowgroup.FieldTotalRows:
		m.ResetTotalRows()
		return nil
	case processingfilerowgroup.FieldRowIndexList:
		m.ResetRowIndexList()
		return nil
	case processingfilerowgroup.FieldGroupRequestCurl:
		m.ResetGroupRequestCurl()
		return nil
	case processingfilerowgroup.FieldGroupResponseRaw:
		m.ResetGroupResponseRaw()
		return nil
	case processingfilerowgroup.FieldStatus:
		m.ResetStatus()
		return nil
	case processingfilerowgroup.FieldErrorDisplay:
		m.ResetErrorDisplay()
		return nil
	case processingfilerowgroup.FieldExecutedTime:
		m.ResetExecutedTime()
		return nil
	case processingfilerowgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case processingfilerowgroup.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProcessingFileRowGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProcessingFileRowGroupMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProcessingFileRowGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProcessingFileRowGroupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProcessingFileRowGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProcessingFileRowGroupMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProcessingFileRowGroupMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFileRowGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProcessingFileRowGroupMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ProcessingFileRowGroup edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	active        *bool
	email         *string
	phone_number  *string
	password_hash *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetActive sets the "active" field.
func (m *UserMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *UserMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *UserMutation) ResetActive() {
	m.active = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.active != nil {
		fields = append(fields, user.FieldActive)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldActive:
		return m.Active()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldActive:
		return m.OldActive(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldActive:
		m.ResetActive()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
