// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/migrate"

	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/configmapping"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/configtask"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/fpsclient"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfile"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerow"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/processingfilerowgroup"
	"git.teko.vn/loyalty-system/loyalty-file-processing/internal/ent/ent/user"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// ConfigMapping is the client for interacting with the ConfigMapping builders.
	ConfigMapping *ConfigMappingClient
	// ConfigTask is the client for interacting with the ConfigTask builders.
	ConfigTask *ConfigTaskClient
	// FpsClient is the client for interacting with the FpsClient builders.
	FpsClient *FpsClientClient
	// ProcessingFile is the client for interacting with the ProcessingFile builders.
	ProcessingFile *ProcessingFileClient
	// ProcessingFileRow is the client for interacting with the ProcessingFileRow builders.
	ProcessingFileRow *ProcessingFileRowClient
	// ProcessingFileRowGroup is the client for interacting with the ProcessingFileRowGroup builders.
	ProcessingFileRowGroup *ProcessingFileRowGroupClient
	// User is the client for interacting with the User builders.
	User *UserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.ConfigMapping = NewConfigMappingClient(c.config)
	c.ConfigTask = NewConfigTaskClient(c.config)
	c.FpsClient = NewFpsClientClient(c.config)
	c.ProcessingFile = NewProcessingFileClient(c.config)
	c.ProcessingFileRow = NewProcessingFileRowClient(c.config)
	c.ProcessingFileRowGroup = NewProcessingFileRowGroupClient(c.config)
	c.User = NewUserClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		ConfigMapping:          NewConfigMappingClient(cfg),
		ConfigTask:             NewConfigTaskClient(cfg),
		FpsClient:              NewFpsClientClient(cfg),
		ProcessingFile:         NewProcessingFileClient(cfg),
		ProcessingFileRow:      NewProcessingFileRowClient(cfg),
		ProcessingFileRowGroup: NewProcessingFileRowGroupClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                    ctx,
		config:                 cfg,
		ConfigMapping:          NewConfigMappingClient(cfg),
		ConfigTask:             NewConfigTaskClient(cfg),
		FpsClient:              NewFpsClientClient(cfg),
		ProcessingFile:         NewProcessingFileClient(cfg),
		ProcessingFileRow:      NewProcessingFileRowClient(cfg),
		ProcessingFileRowGroup: NewProcessingFileRowGroupClient(cfg),
		User:                   NewUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		ConfigMapping.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.ConfigMapping.Use(hooks...)
	c.ConfigTask.Use(hooks...)
	c.FpsClient.Use(hooks...)
	c.ProcessingFile.Use(hooks...)
	c.ProcessingFileRow.Use(hooks...)
	c.ProcessingFileRowGroup.Use(hooks...)
	c.User.Use(hooks...)
}

// ConfigMappingClient is a client for the ConfigMapping schema.
type ConfigMappingClient struct {
	config
}

// NewConfigMappingClient returns a client for the ConfigMapping from the given config.
func NewConfigMappingClient(c config) *ConfigMappingClient {
	return &ConfigMappingClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configmapping.Hooks(f(g(h())))`.
func (c *ConfigMappingClient) Use(hooks ...Hook) {
	c.hooks.ConfigMapping = append(c.hooks.ConfigMapping, hooks...)
}

// Create returns a builder for creating a ConfigMapping entity.
func (c *ConfigMappingClient) Create() *ConfigMappingCreate {
	mutation := newConfigMappingMutation(c.config, OpCreate)
	return &ConfigMappingCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConfigMapping entities.
func (c *ConfigMappingClient) CreateBulk(builders ...*ConfigMappingCreate) *ConfigMappingCreateBulk {
	return &ConfigMappingCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConfigMapping.
func (c *ConfigMappingClient) Update() *ConfigMappingUpdate {
	mutation := newConfigMappingMutation(c.config, OpUpdate)
	return &ConfigMappingUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigMappingClient) UpdateOne(cm *ConfigMapping) *ConfigMappingUpdateOne {
	mutation := newConfigMappingMutation(c.config, OpUpdateOne, withConfigMapping(cm))
	return &ConfigMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigMappingClient) UpdateOneID(id int) *ConfigMappingUpdateOne {
	mutation := newConfigMappingMutation(c.config, OpUpdateOne, withConfigMappingID(id))
	return &ConfigMappingUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConfigMapping.
func (c *ConfigMappingClient) Delete() *ConfigMappingDelete {
	mutation := newConfigMappingMutation(c.config, OpDelete)
	return &ConfigMappingDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigMappingClient) DeleteOne(cm *ConfigMapping) *ConfigMappingDeleteOne {
	return c.DeleteOneID(cm.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ConfigMappingClient) DeleteOneID(id int) *ConfigMappingDeleteOne {
	builder := c.Delete().Where(configmapping.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigMappingDeleteOne{builder}
}

// Query returns a query builder for ConfigMapping.
func (c *ConfigMappingClient) Query() *ConfigMappingQuery {
	return &ConfigMappingQuery{
		config: c.config,
	}
}

// Get returns a ConfigMapping entity by its id.
func (c *ConfigMappingClient) Get(ctx context.Context, id int) (*ConfigMapping, error) {
	return c.Query().Where(configmapping.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigMappingClient) GetX(ctx context.Context, id int) *ConfigMapping {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigMappingClient) Hooks() []Hook {
	return c.hooks.ConfigMapping
}

// ConfigTaskClient is a client for the ConfigTask schema.
type ConfigTaskClient struct {
	config
}

// NewConfigTaskClient returns a client for the ConfigTask from the given config.
func NewConfigTaskClient(c config) *ConfigTaskClient {
	return &ConfigTaskClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `configtask.Hooks(f(g(h())))`.
func (c *ConfigTaskClient) Use(hooks ...Hook) {
	c.hooks.ConfigTask = append(c.hooks.ConfigTask, hooks...)
}

// Create returns a builder for creating a ConfigTask entity.
func (c *ConfigTaskClient) Create() *ConfigTaskCreate {
	mutation := newConfigTaskMutation(c.config, OpCreate)
	return &ConfigTaskCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ConfigTask entities.
func (c *ConfigTaskClient) CreateBulk(builders ...*ConfigTaskCreate) *ConfigTaskCreateBulk {
	return &ConfigTaskCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ConfigTask.
func (c *ConfigTaskClient) Update() *ConfigTaskUpdate {
	mutation := newConfigTaskMutation(c.config, OpUpdate)
	return &ConfigTaskUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConfigTaskClient) UpdateOne(ct *ConfigTask) *ConfigTaskUpdateOne {
	mutation := newConfigTaskMutation(c.config, OpUpdateOne, withConfigTask(ct))
	return &ConfigTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConfigTaskClient) UpdateOneID(id int) *ConfigTaskUpdateOne {
	mutation := newConfigTaskMutation(c.config, OpUpdateOne, withConfigTaskID(id))
	return &ConfigTaskUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ConfigTask.
func (c *ConfigTaskClient) Delete() *ConfigTaskDelete {
	mutation := newConfigTaskMutation(c.config, OpDelete)
	return &ConfigTaskDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConfigTaskClient) DeleteOne(ct *ConfigTask) *ConfigTaskDeleteOne {
	return c.DeleteOneID(ct.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ConfigTaskClient) DeleteOneID(id int) *ConfigTaskDeleteOne {
	builder := c.Delete().Where(configtask.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConfigTaskDeleteOne{builder}
}

// Query returns a query builder for ConfigTask.
func (c *ConfigTaskClient) Query() *ConfigTaskQuery {
	return &ConfigTaskQuery{
		config: c.config,
	}
}

// Get returns a ConfigTask entity by its id.
func (c *ConfigTaskClient) Get(ctx context.Context, id int) (*ConfigTask, error) {
	return c.Query().Where(configtask.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConfigTaskClient) GetX(ctx context.Context, id int) *ConfigTask {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ConfigTaskClient) Hooks() []Hook {
	return c.hooks.ConfigTask
}

// FpsClientClient is a client for the FpsClient schema.
type FpsClientClient struct {
	config
}

// NewFpsClientClient returns a client for the FpsClient from the given config.
func NewFpsClientClient(c config) *FpsClientClient {
	return &FpsClientClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `fpsclient.Hooks(f(g(h())))`.
func (c *FpsClientClient) Use(hooks ...Hook) {
	c.hooks.FpsClient = append(c.hooks.FpsClient, hooks...)
}

// Create returns a builder for creating a FpsClient entity.
func (c *FpsClientClient) Create() *FpsClientCreate {
	mutation := newFpsClientMutation(c.config, OpCreate)
	return &FpsClientCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of FpsClient entities.
func (c *FpsClientClient) CreateBulk(builders ...*FpsClientCreate) *FpsClientCreateBulk {
	return &FpsClientCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for FpsClient.
func (c *FpsClientClient) Update() *FpsClientUpdate {
	mutation := newFpsClientMutation(c.config, OpUpdate)
	return &FpsClientUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *FpsClientClient) UpdateOne(fc *FpsClient) *FpsClientUpdateOne {
	mutation := newFpsClientMutation(c.config, OpUpdateOne, withFpsClient(fc))
	return &FpsClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *FpsClientClient) UpdateOneID(id int) *FpsClientUpdateOne {
	mutation := newFpsClientMutation(c.config, OpUpdateOne, withFpsClientID(id))
	return &FpsClientUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for FpsClient.
func (c *FpsClientClient) Delete() *FpsClientDelete {
	mutation := newFpsClientMutation(c.config, OpDelete)
	return &FpsClientDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *FpsClientClient) DeleteOne(fc *FpsClient) *FpsClientDeleteOne {
	return c.DeleteOneID(fc.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *FpsClientClient) DeleteOneID(id int) *FpsClientDeleteOne {
	builder := c.Delete().Where(fpsclient.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &FpsClientDeleteOne{builder}
}

// Query returns a query builder for FpsClient.
func (c *FpsClientClient) Query() *FpsClientQuery {
	return &FpsClientQuery{
		config: c.config,
	}
}

// Get returns a FpsClient entity by its id.
func (c *FpsClientClient) Get(ctx context.Context, id int) (*FpsClient, error) {
	return c.Query().Where(fpsclient.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *FpsClientClient) GetX(ctx context.Context, id int) *FpsClient {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *FpsClientClient) Hooks() []Hook {
	return c.hooks.FpsClient
}

// ProcessingFileClient is a client for the ProcessingFile schema.
type ProcessingFileClient struct {
	config
}

// NewProcessingFileClient returns a client for the ProcessingFile from the given config.
func NewProcessingFileClient(c config) *ProcessingFileClient {
	return &ProcessingFileClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `processingfile.Hooks(f(g(h())))`.
func (c *ProcessingFileClient) Use(hooks ...Hook) {
	c.hooks.ProcessingFile = append(c.hooks.ProcessingFile, hooks...)
}

// Create returns a builder for creating a ProcessingFile entity.
func (c *ProcessingFileClient) Create() *ProcessingFileCreate {
	mutation := newProcessingFileMutation(c.config, OpCreate)
	return &ProcessingFileCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcessingFile entities.
func (c *ProcessingFileClient) CreateBulk(builders ...*ProcessingFileCreate) *ProcessingFileCreateBulk {
	return &ProcessingFileCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcessingFile.
func (c *ProcessingFileClient) Update() *ProcessingFileUpdate {
	mutation := newProcessingFileMutation(c.config, OpUpdate)
	return &ProcessingFileUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcessingFileClient) UpdateOne(pf *ProcessingFile) *ProcessingFileUpdateOne {
	mutation := newProcessingFileMutation(c.config, OpUpdateOne, withProcessingFile(pf))
	return &ProcessingFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcessingFileClient) UpdateOneID(id int) *ProcessingFileUpdateOne {
	mutation := newProcessingFileMutation(c.config, OpUpdateOne, withProcessingFileID(id))
	return &ProcessingFileUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcessingFile.
func (c *ProcessingFileClient) Delete() *ProcessingFileDelete {
	mutation := newProcessingFileMutation(c.config, OpDelete)
	return &ProcessingFileDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcessingFileClient) DeleteOne(pf *ProcessingFile) *ProcessingFileDeleteOne {
	return c.DeleteOneID(pf.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ProcessingFileClient) DeleteOneID(id int) *ProcessingFileDeleteOne {
	builder := c.Delete().Where(processingfile.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcessingFileDeleteOne{builder}
}

// Query returns a query builder for ProcessingFile.
func (c *ProcessingFileClient) Query() *ProcessingFileQuery {
	return &ProcessingFileQuery{
		config: c.config,
	}
}

// Get returns a ProcessingFile entity by its id.
func (c *ProcessingFileClient) Get(ctx context.Context, id int) (*ProcessingFile, error) {
	return c.Query().Where(processingfile.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcessingFileClient) GetX(ctx context.Context, id int) *ProcessingFile {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProcessingFileClient) Hooks() []Hook {
	return c.hooks.ProcessingFile
}

// ProcessingFileRowClient is a client for the ProcessingFileRow schema.
type ProcessingFileRowClient struct {
	config
}

// NewProcessingFileRowClient returns a client for the ProcessingFileRow from the given config.
func NewProcessingFileRowClient(c config) *ProcessingFileRowClient {
	return &ProcessingFileRowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `processingfilerow.Hooks(f(g(h())))`.
func (c *ProcessingFileRowClient) Use(hooks ...Hook) {
	c.hooks.ProcessingFileRow = append(c.hooks.ProcessingFileRow, hooks...)
}

// Create returns a builder for creating a ProcessingFileRow entity.
func (c *ProcessingFileRowClient) Create() *ProcessingFileRowCreate {
	mutation := newProcessingFileRowMutation(c.config, OpCreate)
	return &ProcessingFileRowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcessingFileRow entities.
func (c *ProcessingFileRowClient) CreateBulk(builders ...*ProcessingFileRowCreate) *ProcessingFileRowCreateBulk {
	return &ProcessingFileRowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcessingFileRow.
func (c *ProcessingFileRowClient) Update() *ProcessingFileRowUpdate {
	mutation := newProcessingFileRowMutation(c.config, OpUpdate)
	return &ProcessingFileRowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcessingFileRowClient) UpdateOne(pfr *ProcessingFileRow) *ProcessingFileRowUpdateOne {
	mutation := newProcessingFileRowMutation(c.config, OpUpdateOne, withProcessingFileRow(pfr))
	return &ProcessingFileRowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcessingFileRowClient) UpdateOneID(id int) *ProcessingFileRowUpdateOne {
	mutation := newProcessingFileRowMutation(c.config, OpUpdateOne, withProcessingFileRowID(id))
	return &ProcessingFileRowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcessingFileRow.
func (c *ProcessingFileRowClient) Delete() *ProcessingFileRowDelete {
	mutation := newProcessingFileRowMutation(c.config, OpDelete)
	return &ProcessingFileRowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcessingFileRowClient) DeleteOne(pfr *ProcessingFileRow) *ProcessingFileRowDeleteOne {
	return c.DeleteOneID(pfr.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ProcessingFileRowClient) DeleteOneID(id int) *ProcessingFileRowDeleteOne {
	builder := c.Delete().Where(processingfilerow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcessingFileRowDeleteOne{builder}
}

// Query returns a query builder for ProcessingFileRow.
func (c *ProcessingFileRowClient) Query() *ProcessingFileRowQuery {
	return &ProcessingFileRowQuery{
		config: c.config,
	}
}

// Get returns a ProcessingFileRow entity by its id.
func (c *ProcessingFileRowClient) Get(ctx context.Context, id int) (*ProcessingFileRow, error) {
	return c.Query().Where(processingfilerow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcessingFileRowClient) GetX(ctx context.Context, id int) *ProcessingFileRow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProcessingFileRowClient) Hooks() []Hook {
	return c.hooks.ProcessingFileRow
}

// ProcessingFileRowGroupClient is a client for the ProcessingFileRowGroup schema.
type ProcessingFileRowGroupClient struct {
	config
}

// NewProcessingFileRowGroupClient returns a client for the ProcessingFileRowGroup from the given config.
func NewProcessingFileRowGroupClient(c config) *ProcessingFileRowGroupClient {
	return &ProcessingFileRowGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `processingfilerowgroup.Hooks(f(g(h())))`.
func (c *ProcessingFileRowGroupClient) Use(hooks ...Hook) {
	c.hooks.ProcessingFileRowGroup = append(c.hooks.ProcessingFileRowGroup, hooks...)
}

// Create returns a builder for creating a ProcessingFileRowGroup entity.
func (c *ProcessingFileRowGroupClient) Create() *ProcessingFileRowGroupCreate {
	mutation := newProcessingFileRowGroupMutation(c.config, OpCreate)
	return &ProcessingFileRowGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProcessingFileRowGroup entities.
func (c *ProcessingFileRowGroupClient) CreateBulk(builders ...*ProcessingFileRowGroupCreate) *ProcessingFileRowGroupCreateBulk {
	return &ProcessingFileRowGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProcessingFileRowGroup.
func (c *ProcessingFileRowGroupClient) Update() *ProcessingFileRowGroupUpdate {
	mutation := newProcessingFileRowGroupMutation(c.config, OpUpdate)
	return &ProcessingFileRowGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProcessingFileRowGroupClient) UpdateOne(pfrg *ProcessingFileRowGroup) *ProcessingFileRowGroupUpdateOne {
	mutation := newProcessingFileRowGroupMutation(c.config, OpUpdateOne, withProcessingFileRowGroup(pfrg))
	return &ProcessingFileRowGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProcessingFileRowGroupClient) UpdateOneID(id int) *ProcessingFileRowGroupUpdateOne {
	mutation := newProcessingFileRowGroupMutation(c.config, OpUpdateOne, withProcessingFileRowGroupID(id))
	return &ProcessingFileRowGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProcessingFileRowGroup.
func (c *ProcessingFileRowGroupClient) Delete() *ProcessingFileRowGroupDelete {
	mutation := newProcessingFileRowGroupMutation(c.config, OpDelete)
	return &ProcessingFileRowGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProcessingFileRowGroupClient) DeleteOne(pfrg *ProcessingFileRowGroup) *ProcessingFileRowGroupDeleteOne {
	return c.DeleteOneID(pfrg.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *ProcessingFileRowGroupClient) DeleteOneID(id int) *ProcessingFileRowGroupDeleteOne {
	builder := c.Delete().Where(processingfilerowgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProcessingFileRowGroupDeleteOne{builder}
}

// Query returns a query builder for ProcessingFileRowGroup.
func (c *ProcessingFileRowGroupClient) Query() *ProcessingFileRowGroupQuery {
	return &ProcessingFileRowGroupQuery{
		config: c.config,
	}
}

// Get returns a ProcessingFileRowGroup entity by its id.
func (c *ProcessingFileRowGroupClient) Get(ctx context.Context, id int) (*ProcessingFileRowGroup, error) {
	return c.Query().Where(processingfilerowgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProcessingFileRowGroupClient) GetX(ctx context.Context, id int) *ProcessingFileRowGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ProcessingFileRowGroupClient) Hooks() []Hook {
	return c.hooks.ProcessingFileRowGroup
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOne returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}
